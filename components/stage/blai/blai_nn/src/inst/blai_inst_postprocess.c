#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "bl808_common.h"
#include "blai_core.h"
#include "blai_def_internal.h"
#include "blai_inst_postprocess.h"
#include "blai_inst_util.h"

void load_postprocess_classification(blai_model_hdl_t hdl, const char** classes_name, int classes_num) {
    BLAI_Model_t *model = (BLAI_Model_t *) hdl;

    model->post_info.classification.classes_name = classes_name;
    model->post_info.classification.classes_num = classes_num;
}
void load_postprocess_face_recongnition(blai_model_hdl_t hdl, const char** names, int names_num, const float** features_list, int features_num) {
    BLAI_Model_t *model = (BLAI_Model_t *) hdl;

    model->post_info.face_recongnition.names = names;
    model->post_info.face_recongnition.names_num = names_num;
    model->post_info.face_recongnition.features_list = features_list;
    model->post_info.face_recongnition.features_num = features_num;
}

void image_classification(struct blai_net_info_t* net, char** imgnet_names, fixed_point_t* DATA_buf, blai_inference_cb result_cb, int num) {
    uint8_t output;
    int max_val = 0;
    int max_loc = 0;
    struct blai_result_t result;

    for (int i = 0; i < num; i++) {
        if (net->use_npu_accel)
            output = (uint8_t)net->layers[net->layer_cnt - 1].output_i8[i];
        else
            output = (uint8_t)MEM_RW(0, i, 0, net->layers[net->layer_cnt - 1].out_layer_mem, DATA_buf, net->patch_size);

        if (max_val < output) {
            max_val = output;
            max_loc = i;
        }
    }
    BL_LOGI("\r\nTOP1 RESULT: %s\r\nCLASSIFICATION DONE\r\n", imgnet_names[max_loc - 1]);
    result.app_type = net->app_type;
    result.r.classification.best_class = max_loc - 1;
    result_cb(&result);
}

void get_output_data(struct blai_net_info_t* net, fixed_point_t* DATA_buf, int layer, int size) {
    uint8_t output;

    for (int i = 0; i < size; i++) {
        if (net->use_npu_accel)
            output = (uint8_t)net->layers[layer].output_i8[i];
        else
            output = (uint8_t)MEM_RW(0, i, 0, net->layers[layer].out_layer_mem, DATA_buf, net->patch_size);

        BL_LOGI("OUTPUT[%d]: %hhx\r\n", i, output);
    }
}


void KWS_classification(struct blai_net_info_t* net, char** imgnet_names, fixed_point_t* DATA_buf, blai_inference_cb result_cb, int num) {
    uint8_t output;
    int max_val = 0;
    int max_loc = 0;
    struct blai_result_t result;

    for (int i = 0; i < num; i++) {
        if (net->use_npu_accel)
            output = (uint8_t)net->layers[net->layer_cnt - 1].output_i8[i];
        else
            output = (uint8_t)MEM_RW(0, i, 0, net->layers[net->layer_cnt - 1].out_layer_mem, DATA_buf, net->patch_size);

        if (max_val < output) {
            max_val = output;
            max_loc = i;
        }
    }
    BL_LOGI("\r\nTOP1 RESULT: %s\r\nKWS DONE\r\n", imgnet_names[max_loc]);
    result.app_type = net->app_type;
    result.r.classification.best_class = max_loc;
    result_cb(&result);
}


void face_recongnition(struct blai_net_info_t* net, char** names, int names_len, const float** feature_list, int feature_len, fixed_point_t* DATA_buf, blai_inference_cb result_cb)
{
    float output_list[128];
    struct blai_result_t result;

    for (int i = 0; i < 128; i++) {
        fixed_point_t pass_data = MEM_RW(0, i, 0, net->layers[net->layer_cnt - 1].out_layer_mem, DATA_buf, net->patch_size);
        float pass_data_flp = fixed_to_float(pass_data, net->layers[net->layer_cnt - 1].fout);
        output_list[i] = pass_data_flp;
    }

    // l2-norm
    int reg_cnt = 0;
    char* val_name;
    float* feature = (float*)feature_list;
    double max_sim = 0;
    char *output_name = "attacker";
    uint8_t output_name_idx = 0xFF;
    for (int i = 0; i < names_len; i++) {
        val_name = names[i];
        feature = (float *) feature_list+(i*feature_len);
        double accum1 = 0.;
        double accum2 = 0.;
        for (int i = 0; i < 128; ++i) {
            accum1 += output_list[i] * output_list[i];
            int feature_index = i + 128 * (reg_cnt / 129);
            float f1 =feature[feature_index];
            accum2 += f1*f1;
        }
        double norm1 = sqrt(accum1);
        double norm2 = sqrt(accum2);
        double out1[128] = { 0. };
        double out2[128] = { 0. };
        double dist = 0;
        double sim = 0;
        for (int i = 0; i < 128; ++i) {
            out1[i] = output_list[i] / norm1;
            int feature_index = i + 128 * (reg_cnt / 129);
            out2[i] = feature[feature_index] / norm2;
            dist += (out1[i] - out2[i]) * (out1[i] - out2[i]);
            sim += (out1[i] * out2[i]);
        }
        if (sim > 0.63 && sim > max_sim) {
            output_name = val_name;
            output_name_idx = i;
        }
        max_sim = (sim > 0.63 && sim > max_sim) ? sim : max_sim;
        BL_LOGI("val_name: %s, dist: %f, sim: %f\r\n",  val_name, dist, sim);
    }
    BL_LOGI("Who are you: %s\r\n", output_name);

    result.r.fr.best_class = output_name_idx;
    result.app_type = net->app_type;
    result_cb(&result);
}

image meanAxis0(image src)
{
    int num = src.h;
    int dim = src.w;

    image output = BL_make_image(dim, 1, 1);
    for (int i = 0; i < dim; i++)
    {
        float sum = 0;
        for (int j = 0; j < num; j++)
        {
            int index = j * dim + i;
            sum += src.data[index];
        }
        output.data[i] = sum / num;
    }

    return output;
}

image elementwiseMinus(image A, image B)
{
    //cv::Mat output(A.rows, A.cols, A.type());
    image output = BL_make_image(A.w, A.h, 1);
    //assert(B.w == A.w);
    if (B.w == A.w)
    {
        for (int i = 0; i < A.h; i++)
        {
            for (int j = 0; j < B.w; j++)
            {
                int index = i * A.w + j;
                output.data[index] = A.data[index] - B.data[j];
            }
        }
    }
    return output;
}

image image_dot_average(image dst_demean, image src_demean, int num) {

    image output = BL_make_image(src_demean.w, dst_demean.w, src_demean.c);
    float pass_data = 0;
    for (int dst_w = 0; dst_w < dst_demean.w; dst_w++) {
        for (int src_w = 0; src_w < src_demean.w; src_w++) {
            pass_data = 0;
            for (int hin = 0; hin < dst_demean.h; hin++) {
                int dst_index = hin * dst_demean.w + dst_w;
                int src_index = hin * src_demean.w + src_w;
                pass_data += dst_demean.data[dst_index] * src_demean.data[src_index];
            }
            int out_index = dst_w * src_demean.w + src_w;
            output.data[out_index] = pass_data / (float)(num);
        }
    }
    return output;
}

float determinant(float matrix[10][10], int n) {
    float det = 0;
    float submatrix[10][10];
    if (n == 2)
        return ((matrix[0][0] * matrix[1][1]) - (matrix[1][0] * matrix[0][1]));
    else {
        for (int x = 0; x < n; x++) {
            int subi = 0;
            for (int i = 1; i < n; i++) {
                int subj = 0;
                for (int j = 0; j < n; j++) {
                    if (j == x)
                        continue;
                    submatrix[subi][subj] = matrix[i][j];
                    subj++;
                }
                subi++;
            }
            det = det + (pow(-1, x) * matrix[0][x] * determinant(submatrix, n - 1));
        }
    }
    return det;
}

image similarTransform(image src, image dst) {
    int num = src.h;
    int dim = src.w;
    image src_mean = meanAxis0(src);
    image dst_mean = meanAxis0(dst);
    image src_demean = elementwiseMinus(src, src_mean);
    image dst_demean = elementwiseMinus(dst, dst_mean);
    image A = image_dot_average(dst_demean, src_demean, num);

    image d = BL_make_image(1, dim, 1);
    for (int i = 0; i < dim; i++)
        d.data[i] = 1.0f;
    // calculate determinant
    float det[10][10] = { 0 };
    for (int i = 0; i < A.w; i++) {
        for (int j = 0; j < A.h; j++) {
            det[j][i] = A.data[j * A.w + i];
        }
    }

    if (determinant(det, dim) < 0) {
        d.data[dim - 1] = -1;
    }


    image T = BL_make_image(dim + 1, dim + 1, 1);
    for (int i = 0; i < T.w; i++) {
        for (int j = 0; j < T.h; j++) {
            if (i == j) T.data[j * A.w + i] = 1;
        }
    }

    BLAI_FREE(src_mean.data);
    BLAI_FREE(dst_mean.data);
    BLAI_FREE(src_demean.data);
    BLAI_FREE(dst_demean.data);
    BLAI_FREE(A.data);
    BLAI_FREE(d.data);

    return T;
}

void show_mem_full(bool* mem_full){
    printf("\r\n[BLAI MEM STATUS]\r\n");
    for(int i = 0; i < 32; i++){
        if(mem_full[i]) printf("1 ");
        else         printf("0 ");
    }
    printf(" \r\n");
}
int8_t* alloc_blai_patch(bool* mem_full, int size, fixed_point_t* DATA_buf, int patch_size){
    int num = (size % patch_size == 0) ? size / patch_size : 1 + size / patch_size;
    int mem_addr = -1;
    bool jump = false;
    for(int i = 0; i < 32; i++){
        for(int j = 0; j < num; j++){
            if(mem_full[i + j]) break;
            if(j == num - 1){
                mem_addr = i;
                for(int k = 0; k < num;k++){
                    mem_full[i + k] = true;
                }
                jump = true;
            }
        }
        if(jump) break;
    }
    //printf("blai alloc mem_addr:%d \r\n", mem_addr);
    //show_mem_full(mem_full);
    if(mem_addr == -1) printf("ALLOC BLAI PATCH ERROR\r\n");
    return MEM_PTR(mem_addr, DATA_buf, patch_size);
}
/*
float* prior_box_tf(int* image_sizes, int* min_sizes, int* steps, int anchors_num, int *num, bool* mem_full, fixed_point_t* DATA_buf, int patch_size) {
    int size = anchors_num / 2;
    int output_size = 0;
    for (int i = 0; i < size; i++) {
        int feature_map_w = image_sizes[0] / steps[i];
        int feature_map_h = image_sizes[1] / steps[i];
        output_size += feature_map_w * feature_map_h * 2 * 4;
    }
    *num = output_size / 4;
    float* output = (float*) alloc_blai_patch(mem_full, output_size, DATA_buf, patch_size);
    int cnt = 0;

    for(int i = 0; i < size; i++){
        int feature_map_w = image_sizes[0] / steps[i];
        int feature_map_h = image_sizes[1] / steps[i];

        for (int h = 0; h < feature_map_h; h++) {
            for (int w = 0; w < feature_map_w; w++) {
                for (int k = 0; k < 2; k++) {
                    output[cnt + 0] = (float)(w + 0.5) * steps[i] / image_sizes[0];
                    output[cnt + 1] = (float)(h + 0.5) * steps[i] / image_sizes[1];
                    output[cnt + 2] = (float)min_sizes[2 * i + k] / image_sizes[0];
                    output[cnt + 3] = (float)min_sizes[2 * i + k] / image_sizes[1];
                    cnt+=4;
                }
            }
        }

    }
    return output;
}
*/
void decode_bbox(struct cpu_inst_layer_t *bbox, float* prior_box, float* variance, float* bbox_output) {
    int cnt = 0;
    float temp[4] = { 0 };
    for (int hin = 0; hin < bbox->out_h; hin++) {
        for (int win = 0; win < bbox->out_w; win++) {
            for (int cin = 0; cin < bbox->out_c; cin++) {
                if (cin < 2) {
                    temp[cnt % 4] = prior_box[cnt] + bbox_output[cnt] * variance[0] * prior_box[cnt + 2];
                }
                else {
                    temp[cnt % 4] = prior_box[cnt] * exp(bbox_output[cnt] * variance[1]);
                }
                cnt++;
            }
            bbox_output[cnt - 4] = temp[0] - temp[2] / 2;
            bbox_output[cnt - 3] = temp[1] - temp[3] / 2;
            bbox_output[cnt - 2] = temp[0] + temp[2] / 2;
            bbox_output[cnt - 1] = temp[1] + temp[3] / 2;
        }
    }
}

void decode_landmark(struct cpu_inst_layer_t* landmark, float* prior_box, float* variance, float* landmark_output) {
    int cnt = 0;
    int prior_cnt = 0;
    for (int hin = 0; hin < landmark->out_h; hin++) {
        for (int win = 0; win < landmark->out_w; win++) {
            for (int cin = 0; cin < landmark->out_c; cin++) {
                int offset = (cin % 2 == 0) ? 0 : 1;
                landmark_output[cnt] = prior_box[prior_cnt + offset] + landmark_output[cnt] * variance[0] * prior_box[prior_cnt + offset + 2];
                cnt++;
            }
            prior_cnt += 4;
        }
    }
}

// A pair of diagonal corners of the box.
struct BoxCornerEncoding_NMS {
    float y1;
    float x1;
    float y2;
    float x2;
};

float ComputeIntersectionOverUnion(const float* boxes, const int i,
    const int j) {
    struct BoxCornerEncoding_NMS box_i = ((const struct BoxCornerEncoding_NMS*)boxes)[i];
    struct BoxCornerEncoding_NMS box_j = ((const struct BoxCornerEncoding_NMS*)boxes)[j];
    const float box_i_y_min = fmin(box_i.y1, box_i.y2);
    const float box_i_y_max = fmax(box_i.y1, box_i.y2);
    const float box_i_x_min = fmin(box_i.x1, box_i.x2);
    const float box_i_x_max = fmax(box_i.x1, box_i.x2);
    const float box_j_y_min = fmin(box_j.y1, box_j.y2);
    const float box_j_y_max = fmax(box_j.y1, box_j.y2);
    const float box_j_x_min = fmin(box_j.x1, box_j.x2);
    const float box_j_x_max = fmax(box_j.x1, box_j.x2);

    const float area_i =
        (box_i_y_max - box_i_y_min) * (box_i_x_max - box_i_x_min);
    const float area_j =
        (box_j_y_max - box_j_y_min) * (box_j_x_max - box_j_x_min);
    if (area_i <= 0 || area_j <= 0) return 0.0;
    const float intersection_ymax = fmin(box_i_y_max, box_j_y_max);
    const float intersection_xmax = fmin(box_i_x_max, box_j_x_max);
    const float intersection_ymin = fmax(box_i_y_min, box_j_y_min);
    const float intersection_xmin = fmax(box_i_x_min, box_j_x_min);
    const float intersection_area =
        fmax(intersection_ymax - intersection_ymin, 0.0) *
        fmax(intersection_xmax - intersection_xmin, 0.0);
    return intersection_area / (area_i + area_j - intersection_area);
}

struct Candidate {
        int index;
        float score;
        int suppress_begin_index;
    };


void insert_element_by_score(struct Candidate* candidate_priority_queue, int index, float score, int cnt){
    int target = cnt;
    for(int i = 0; i < cnt; i++){
        if(score > candidate_priority_queue[i].score){
            target = i;
            break;
        }
    }
    struct Candidate* output = &candidate_priority_queue[target + 1];
    struct Candidate* input = &candidate_priority_queue[target];
    struct Candidate* temp = &candidate_priority_queue[cnt + 1];
    int size = (cnt - target) * sizeof(struct Candidate);

    memcpy(temp, input, size);
    memcpy(output, temp, size);

    candidate_priority_queue[target].index = index;
    candidate_priority_queue[target].score = score;
    candidate_priority_queue[target].suppress_begin_index = 0;

}

void NonMaxSuppression(const float* boxes, const int num_boxes,
    const float* scores, const int max_output_size,
    const float iou_threshold,
    const float score_threshold,
    const float soft_nms_sigma, int* selected_indices,
    float* selected_scores,
    int* num_selected_indices, bool* mem_full, fixed_point_t* DATA_buf, int patch_size ) {

    // Priority queue to hold candidates.
    /*auto cmp = [](const struct Candidate bs_i, const struct Candidate bs_j) {
        return bs_i.score < bs_j.score;
    };
    std::priority_queue<Candidate, std::deque<Candidate>, decltype(cmp)>
        candidate_priority_queue(cmp);*/
    // Populate queue with candidates above the score threshold.
    int candidate_size = num_boxes * sizeof(struct Candidate);
    int candidate_cnt = 0;
    struct Candidate* candidate_priority_queue = (struct Candidate*) alloc_blai_patch(mem_full, candidate_size, DATA_buf, patch_size);
    for (int i = 0; i < num_boxes; ++i) {
        if (scores[i] > score_threshold){
           // struct Candidate c = candidate_priority_queue[candidate_cnt];

            /*candidate_priority_queue[candidate_cnt].index = i;
            candidate_priority_queue[candidate_cnt].score = scores[i];
            candidate_priority_queue[candidate_cnt].suppress_begin_index = 0;*/
        insert_element_by_score(candidate_priority_queue, i, scores[i], candidate_cnt);
            candidate_cnt++;
        }
    }

    *num_selected_indices = 0;
    int num_outputs = fmin(candidate_cnt, max_output_size);
    if (num_outputs == 0) return;

    // NMS loop.
    float scale = 0;
    if (soft_nms_sigma > 0.0) {
        scale = -0.5 / soft_nms_sigma;
    }
    int cnt = 0;
    while (*num_selected_indices < num_outputs &&
        candidate_cnt > 0 && cnt < candidate_cnt) {
        struct Candidate next_candidate = candidate_priority_queue[cnt];
        const float original_score = next_candidate.score;
        cnt++;

        // Overlapping boxes are likely to have similar scores, therefore we
        // iterate through the previously selected boxes backwards in order to
        // see if `next_candidate` should be suppressed. We also enforce a property
        // that a candidate can be suppressed by another candidate no more than
        // once via `suppress_begin_index` which tracks which previously selected
        // boxes have already been compared against next_candidate prior to a given
        // iteration.  These previous selected boxes are then skipped over in the
        // following loop.
        bool should_hard_suppress = false;

        for (int j = *num_selected_indices - 1;
            j >= next_candidate.suppress_begin_index; --j) {
            const float iou = ComputeIntersectionOverUnion(
                boxes, next_candidate.index, selected_indices[j]);

            // First decide whether to perform hard suppression.
            if (iou >= iou_threshold) {
                should_hard_suppress = true;
                break;
            }

            // Suppress score if NMS sigma > 0.
            if (soft_nms_sigma > 0.0) {
                next_candidate.score =
                    next_candidate.score * exp(scale * iou * iou);
            }

            // If score has fallen below score_threshold, it won't be pushed back into
            // the queue.
            if (next_candidate.score <= score_threshold) break;
        }
        // If `next_candidate.score` has not dropped below `score_threshold`
        // by this point, then we know that we went through all of the previous
        // selections and can safely update `suppress_begin_index` to
        // `selected.size()`. If on the other hand `next_candidate.score`
        // *has* dropped below the score threshold, then since `suppress_weight`
        // always returns values in [0, 1], further suppression by items that were
        // not covered in the above for loop would not have caused the algorithm
        // to select this item. We thus do the same update to
        // `suppress_begin_index`, but really, this element will not be added back
        // into the priority queue.
        next_candidate.suppress_begin_index = *num_selected_indices;

        if (!should_hard_suppress) {
            if (next_candidate.score == original_score) {
                // Suppression has not occurred, so select next_candidate.
                selected_indices[*num_selected_indices] = next_candidate.index;
                if (selected_scores) {
                    selected_scores[*num_selected_indices] = next_candidate.score;
                }
                ++* num_selected_indices;
            }
            if (next_candidate.score > score_threshold) {
                // Soft suppression might have occurred and current score is still
                // greater than score_threshold; add next_candidate back onto priority
                // queue.
                //candidate_priority_queue.push(next_candidate);
                cnt--;
            }
        }
    }
}

void retina_face(struct blai_net_info_t* net, char** imgnet_names, fixed_point_t* DATA_buf, int image_width, int image_height, blai_inference_cb result_cb){
    //retina face setting
    float variance[2] = { 0.1, 0.2 };
    int anchors_num = 6;
    int anchors[6] = {8,16,32,64,128,256};
    int steps[3] = {8,16,32};
    int image_sizes[2] = { net->layers[0].w, net->layers[0].h };
    float iou_threshold = 0.4;
    float score_threshold = 0.5;
    float soft_nms_sigma = 0.0;
    int max_output_size = 50;

    int img_cols = image_width;
    int img_rows = image_height;
    struct blai_result_t result;
    // selected indices equals to max_output_size
    int output_selected_indices[50] = {0};
    float output_selected_scores[50] = {0};
    int output_num_selected_indices = 0;

    bool mem_full[32] = {false};
    struct cpu_inst_layer_t landmark = {0};
    struct cpu_inst_layer_t score = {0};
    struct cpu_inst_layer_t bbox = {0};
    for(int i = 0; i < net->output_num; i++){
        int channel = net->layers[net->output_layer[i]].out_c;
        int mem_size = 0;
        int num = 0;
        if (channel == 4) {
            bbox = net->layers[net->output_layer[i]];

            if(bbox.out_layer_mem < 32){
                mem_size = bbox.out_w * bbox.out_h * bbox.out_c * 4;
                num = 1 + mem_size / net->patch_size;
                for(int k = 0; k < num; k++)
                    mem_full[bbox.out_layer_mem + k] = true;
            }
        }
        else if (channel == 10) {
            landmark = net->layers[net->output_layer[i]];

            if(landmark.out_layer_mem < 32){
                mem_size = landmark.out_w * landmark.out_h * landmark.out_c * 4;
                num = 1 + mem_size / net->patch_size;
                for(int k = 0; k < num; k++)
                    mem_full[landmark.out_layer_mem + k] = true;
            }
        }
        else if (channel == 2) {
            score = net->layers[net->output_layer[i]];

            if(score.out_layer_mem < 32){
                mem_size = score.out_w * score.out_h * score.out_c * 4;
                num = 1 + mem_size / net->patch_size;
                for(int k = 0; k < num; k++)
                    mem_full[score.out_layer_mem + k] = true;
            }
        }
    }

    int score_size = score.out_h * score.out_w * 1 * sizeof(float);

    float* score_sm = (float*) alloc_blai_patch(mem_full, score_size, DATA_buf, net->patch_size);
    float* score_output = (float*) MEM_PTR(score.out_layer_mem, DATA_buf, net->patch_size);
    float* bbox_output = (float*) MEM_PTR(bbox.out_layer_mem, DATA_buf, net->patch_size);
    float* landmark_output = (float*) MEM_PTR(landmark.out_layer_mem, DATA_buf, net->patch_size);
    for (int i = 0; i < score.out_h * score.out_w * score.out_c; i+=2) {
        float class0 = exp(score_output[i]);
        float class1 = exp(score_output[i + 1]);
        float sum_exp = class0 + class1;
        score_sm[i/2] = class1 / sum_exp;
    }

    //int num_boxes = 0;
    //float* prior_box = prior_box_tf(image_sizes, anchors,steps, anchors_num, &num_boxes, mem_full, DATA_buf, net->patch_size);
    int num_boxes = net->prior_bbox_num;
    float* prior_box = net->prior_bbox;

    decode_bbox(&bbox, prior_box, variance, bbox_output);
    decode_landmark(&landmark, prior_box, variance, landmark_output);
    NonMaxSuppression(
        bbox_output, num_boxes, score_sm,
        max_output_size, iou_threshold, score_threshold, soft_nms_sigma,
        output_selected_indices, output_selected_scores,
        &output_num_selected_indices, mem_full, DATA_buf, net->patch_size);

    for (int i = 0; i < output_num_selected_indices; i++) {
        int x = img_cols * bbox_output[output_selected_indices[i] * 4];
        int y = img_rows * bbox_output[output_selected_indices[i] * 4 + 1];
        int w = img_cols * (bbox_output[output_selected_indices[i] * 4 + 2] - bbox_output[output_selected_indices[i] * 4]);
        int h = img_rows * (bbox_output[output_selected_indices[i] * 4 + 3] - bbox_output[output_selected_indices[i] * 4 + 1]);
        printf("[%d] face(%d%%): [%d %d %d %d] landmark: ", i, (int)(score_sm[output_selected_indices[i]] * 100), x, y, w, h);

        for (int j = 0; j < 5; j++) {
            int lm_x = img_cols * landmark_output[output_selected_indices[i] * 10 + j * 2];
            int lm_y = img_rows * landmark_output[output_selected_indices[i] * 10 + j * 2 + 1];
            printf("[%d %d]", lm_x, lm_y);
            if (j < 4) printf(", ");
        }
        printf( "\r\n");

        result.r.objdet.rect.x = x;
        result.r.objdet.rect.y = y;
        result.r.objdet.rect.w = w;
        result.r.objdet.rect.h = h;
        //save landmarks
        result.r.landmark.lx1.x = img_cols * landmark_output[output_selected_indices[i] * 10 + 0 * 2];
        result.r.landmark.lx1.y = img_rows * landmark_output[output_selected_indices[i] * 10 + 0 * 2 + 1];
        result.r.landmark.lx2.x = img_cols * landmark_output[output_selected_indices[i] * 10 + 1 * 2];
        result.r.landmark.lx2.y = img_rows * landmark_output[output_selected_indices[i] * 10 + 1 * 2 + 1];
        result.r.landmark.lx3.x = img_cols * landmark_output[output_selected_indices[i] * 10 + 2 * 2];
        result.r.landmark.lx3.y = img_rows * landmark_output[output_selected_indices[i] * 10 + 2 * 2 + 1];
        result.r.landmark.lx4.x = img_cols * landmark_output[output_selected_indices[i] * 10 + 3 * 2];
        result.r.landmark.lx4.y = img_rows * landmark_output[output_selected_indices[i] * 10 + 3 * 2 + 1];
        result.r.objdet.best_class = 0;
        result.r.objdet.prob = score_sm[output_selected_indices[i]] * 100;
        result.app_type = net->app_type;
        result_cb(&result);
    }
}

void retina_person(struct blai_net_info_t* net, char** imgnet_names, fixed_point_t* DATA_buf, int image_width, int image_height, blai_inference_cb result_cb){
    //retina face setting
    float variance[2] = { 0.1, 0.2 };
    int anchors_num = 6;
    int steps[3] = {8,16,32};
    int image_sizes[2] = { net->layers[0].w, net->layers[0].h };
    float iou_threshold = 0.4;
    float score_threshold = 0.5;
    float soft_nms_sigma = 0.0;
    int max_output_size = 50;

    int img_cols = image_width;
    int img_rows = image_height;
    struct blai_result_t result;
    // selected indices equals to max_output_size
    int output_selected_indices[50] = {0};
    float output_selected_scores[50] = {0};
    int output_num_selected_indices = 0;

    bool mem_full[32] = {false};
    struct cpu_inst_layer_t score = {0};
    struct cpu_inst_layer_t bbox = {0};
    for(int i = 0; i < net->output_num; i++){
        int channel = net->layers[net->output_layer[i]].out_c;
        int mem_size = 0;
        int num = 0;
        if (channel == 4) {
            bbox = net->layers[net->output_layer[i]];

            if(bbox.out_layer_mem < 32){
                mem_size = bbox.out_w * bbox.out_h * bbox.out_c * 4;
                num = 1 + mem_size / net->patch_size;
                for(int k = 0; k < num; k++)
                    mem_full[bbox.out_layer_mem + k] = true;

            }
        }
        else if (channel == 2) {
            score = net->layers[net->output_layer[i]];

            if(score.out_layer_mem < 32){
                mem_size = score.out_w * score.out_h * score.out_c * 4;
                num = 1 + mem_size / net->patch_size;
                for(int k = 0; k < num; k++)
                    mem_full[score.out_layer_mem + k] = true;
            }
        }
    }

    int score_size = score.out_h * score.out_w * 1 * sizeof(float);

    float* score_sm = (float*) alloc_blai_patch(mem_full, score_size, DATA_buf, net->patch_size);
    float* score_output = (float*) MEM_PTR(score.out_layer_mem, DATA_buf, net->patch_size);
    float* bbox_output = (float*) MEM_PTR(bbox.out_layer_mem, DATA_buf, net->patch_size);

    for (int i = 0; i < score.out_h * score.out_w * score.out_c; i+=2) {
        float class0 = exp(score_output[i]);
        float class1 = exp(score_output[i + 1]);
        float sum_exp = class0 + class1;
        score_sm[i/2] = class1 / sum_exp;
    }

    int num_boxes = net->prior_bbox_num;
    float* prior_box = net->prior_bbox;

    decode_bbox(&bbox, prior_box, variance, bbox_output);

    NonMaxSuppression(
        bbox_output, num_boxes, score_sm,
        max_output_size, iou_threshold, score_threshold, soft_nms_sigma,
        output_selected_indices, output_selected_scores,
        &output_num_selected_indices, mem_full, DATA_buf, net->patch_size);

    for (int i = 0; i < output_num_selected_indices; i++) {
        int x = img_cols * bbox_output[output_selected_indices[i] * 4];
        int y = img_rows * bbox_output[output_selected_indices[i] * 4 + 1];
        int w = img_cols * (bbox_output[output_selected_indices[i] * 4 + 2] - bbox_output[output_selected_indices[i] * 4]);
        int h = img_rows * (bbox_output[output_selected_indices[i] * 4 + 3] - bbox_output[output_selected_indices[i] * 4 + 1]);
        printf("[%d] Person(%d%%): [%d %d %d %d] \r\n", i, (int)(score_sm[output_selected_indices[i]] * 100), x, y, w, h);


        result.r.objdet.rect.x = x;
        result.r.objdet.rect.y = y;
        result.r.objdet.rect.w = w;
        result.r.objdet.rect.h = h;
        result.r.objdet.best_class = 0;
        result.r.objdet.prob = score_sm[output_selected_indices[i]] * 100;
        result.app_type = net->app_type;
        result_cb(&result);
    }
}

float fast_exp_s(float input, float* LUT){
    int index = (input > 10.0) ? 20000 : (input < -10.0) ? 0 : (input + 10.0) * 1000;
    return LUT[index];
}


float* bbox_transform_inv(float* boxes, float* deltas, int num, int* image_shape, float* EXP_LUT) {
    float dx, dy, dw, dh;
    float widths, heights, ctr_x, ctr_y;
    float pred_ctr_x, pred_ctr_y, pred_w, pred_h;
    for (int i = 0; i < num; i++) {
        int offset = i * 4;
        dx = deltas[offset + 0];
        dy = deltas[offset + 1];
        dw = deltas[offset + 2];
        dh = deltas[offset + 3];

        widths = boxes[offset + 2] - boxes[offset + 0] + 1.0;
        heights = boxes[offset + 3] - boxes[offset + 1] + 1.0;
        ctr_x = boxes[offset + 0] + 0.5 * widths;
        ctr_y = boxes[offset + 1] + 0.5 * heights;

        pred_ctr_x = dx * widths + ctr_x;
        pred_ctr_y = dy * heights + ctr_y;

        if(EXP_LUT){
            pred_w = fast_exp_s(dw, EXP_LUT) * widths;
            pred_h = fast_exp_s(dh, EXP_LUT) * heights;
        }
        else{
            pred_w = exp(dw) * widths;
            pred_h = exp(dh) * heights;
        }

        boxes[offset + 1] = fmax(fmin(pred_ctr_x - 0.5 * pred_w, image_shape[0] - 1), 0);
        boxes[offset + 3] = fmax(fmin(pred_ctr_x + 0.5 * pred_w, image_shape[0] - 1), 0);
        boxes[offset + 0] = fmax(fmin(pred_ctr_y - 0.5 * pred_h, image_shape[1] - 1), 0);
        boxes[offset + 2] = fmax(fmin(pred_ctr_y + 0.5 * pred_h, image_shape[1] - 1), 0);
        //if(i < 10) printf("[%f %f %f %f] [%f %f %f %f]\r\n", dx,dy,dw,dh, widths, heights, ctr_x, ctr_y);
    }

    return boxes;
}

void fast_logistic(float* input, float* output, int size, float* LUT) {
    for (int i = 0; i < size; i++) {
        int index = (input[i] > 10.0) ? 20000 : (input[i] < -10.0) ? 0 : (input[i] + 10.0) * 1000;
        output[i] = LUT[index];
    }
}


void retina(struct blai_net_info_t* net, char** imgnet_names, int class_num, fixed_point_t* DATA_buf, int image_width, int image_height, blai_inference_cb result_cb){
    int image_sizes[2] = { net->layers[0].w, net->layers[0].h };
    int img_cols = image_width;
    int img_rows = image_height;
    struct blai_result_t result;
    float iou_threshold = 0.5;
    float score_threshold = 0.2;
    float soft_nms_sigma = 0.0;
    // selected indices equals to max_output_size
    int max_output_size = 50;
    int output_selected_indices[50] = {0};
    float output_selected_scores[50] = {0};
    int output_num_selected_indices = 0;

    bool mem_full[32] = {false};
    struct cpu_inst_layer_t score = {0};
    struct cpu_inst_layer_t bbox = {0};
    for(int i = 0; i < net->output_num; i++){
        int channel = net->layers[net->output_layer[i]].out_c;
        int mem_size = 0;
        int num = 0;
        if (channel == 4) {
            bbox = net->layers[net->output_layer[i]];

            if(bbox.out_layer_mem < 32){
                mem_size = bbox.out_w * bbox.out_h * bbox.out_c * 4;
                num = 1 + mem_size / net->patch_size;

                for(int k = 0; k < num; k++)
                    mem_full[bbox.out_layer_mem + k] = true;

            }
        }
        else{
            score = net->layers[net->output_layer[i]];

            if(score.out_layer_mem < 32){
                mem_size = score.out_w * score.out_h * score.out_c * 4;
                num = 1 + mem_size / net->patch_size;

                for(int k = 0; k < num; k++)
                    mem_full[score.out_layer_mem + k] = true;
            }
        }
    }

    float* score_output = (float*) MEM_PTR(score.out_layer_mem, DATA_buf, net->patch_size);
    float* bbox_output = (float*) MEM_PTR(bbox.out_layer_mem, DATA_buf, net->patch_size);

    if(net->LUT){
        fast_logistic(score_output, score_output, score.w * score.h * score.c, net->LUT);
    }
    else{
        for (int i = 0; i < score.w * score.h * score.c;i++) {
            score_output[i] = 1.f / (1.f + exp(-score_output[i]));
        }
    }

    int num_boxes = net->prior_bbox_num;
    float* prior_bbox = net->prior_bbox;

    float* boxes_pred = bbox_transform_inv(prior_bbox, bbox_output, num_boxes, image_sizes, net->LUT2);
    float* obj_scores = (float*) alloc_blai_patch(mem_full, num_boxes * 4, DATA_buf, net->patch_size);

    int det_cnt = 0;
    for (int i = 0; i < class_num; i++) {
        for (int j = 0; j < num_boxes; j++) obj_scores[j] = score_output[j * class_num + i];

        output_num_selected_indices = 0;
        NonMaxSuppression(
            boxes_pred, num_boxes, obj_scores,
            max_output_size, iou_threshold, score_threshold, soft_nms_sigma,
            output_selected_indices, output_selected_scores,
            &output_num_selected_indices, mem_full, DATA_buf, net->patch_size);


        for (int k = 0; k < output_num_selected_indices; k++) {
            int x = img_cols * boxes_pred[output_selected_indices[k] * 4 + 1] / image_sizes[0];
            int y = img_rows * boxes_pred[output_selected_indices[k] * 4 + 0] / image_sizes[1];
            int w = img_cols * (boxes_pred[output_selected_indices[k] * 4 + 3] - boxes_pred[output_selected_indices[k] * 4 + 1]) / image_sizes[0];
            int h = img_rows * (boxes_pred[output_selected_indices[k] * 4 + 2] - boxes_pred[output_selected_indices[k] * 4 + 0]) / image_sizes[1];
            printf("[%d] %s(%d%%): [%d %d %d %d]\n", det_cnt, imgnet_names[i], (int)(obj_scores[output_selected_indices[k]] * 100), x, y, w, h);
            det_cnt++;

            result.r.objdet.rect.x = (x < 0) ? 0 : x;
            result.r.objdet.rect.y = (y < 0) ? 0 : y;
            result.r.objdet.rect.w = w;
            result.r.objdet.rect.h = h;
            result.r.objdet.best_class = i;
            result.r.objdet.prob = obj_scores[output_selected_indices[i]] * 100;
            result.app_type = net->app_type;
            result_cb(&result);
        }
    }
}


void face_recognition_evaluation(struct blai_net_info_t* net, char** face_IDs, fixed_point_t* DATA_buf, int image_width, int image_height, blai_inference_cb result_cb){
 // test feature list
 uint8_t feature_list[] = {
     0x5b,0xa6,0x7a,0xb1,0x53,0x8a,0x8e,0x82,0x6a,0x75,0x99,0x83,0x6c,0x6c,0x76,0x81,0xaf,0x82,0x60,0x71,0x7e,0x6d,0x74,0x7a,0x73,0x4f,0x78,0x81,0x6e,0x91,0x82,0xa1,0x96,0x8d,0x86,0x78,0x7d,0xaa,0x73,0x61,0x6d,0x89,0x8d,0x6f,0x80,0x98,0x72,0xa3,0x73,0x7d,0x8b,0x7c,0x5a,0xa3,0x7a,0x81,0xa2,0x96,0x98,0x80,0x56,0x90,0x93,0x81,0x71,0x91,0x68,0x6f,0xa2,0x8e,0x72,0x83,0x79,0x84,0x94,0x8d,0x7b,0x8f,0xa7,0x95,0x77,0x7f,0x57,0x7a,0x87,0x9c,0x9e,0x90,0x7a,0x85,0x8b,0xa5,0x8c,0x5a,0x73,0x6f,0x79,0xad,0x68,0x7a,0x7e,0x6f,0x9b,0x71,0x61,0x7d,0x86,0x9d,0xa1,0x78,0x8d,0x8a,0x78,0x8b,0x69,0x96,0x8f,0x8c,0x6a,0x81,0xa2,0x99,0x91,0x5c,0x99,0x94,0x66,0x9d,0x8b,0x8f,0x5a,0x8d,0x66,0x75,0x77,0x99,0x9c,0x75,0x85,0x58,0x8a,0x4d,0x7d,0x9a,0x8c,0x5d,0x8a,0x8e,0x84,0x86,0x64,0x83,0x43,0x50,0x8f,0x5f,0x7d,0x6c,0x77,0x98,0x92,0x84,0x63,0x8e,0x74,0x85,0x8a,0x8f,0x49,0x6d,0x62,0xa1,0x9a,0x79,0x77,0xc5,0x86,0x7f,0x89,0x64,0x87,0x67,0x96,0x8d,0x74,0x8a,0x99,0x5d,0x55,0x8c,0x6f,0x7d,0x6d,0x96,0x4b,0x6f,0x75,0x87,0x69,0x89,0x85,0x7a,0x8e,0x64,0x7f,0x91,0x8d,0x7e,0x89,0x8d,0x8a,0x8e,0x85,0x7e,0x8f,0x7c,0xa0,0xa1,0x78,0x7e,0x90,0x74,0x83,0x7e,0x64,0x82,0x85,0x8d,0x64,0xa5,0x92,0x78,0x8c,0x72,0x64,0x50,0xa2,0x96,0x7b,0x67,0x97,0x85,0x72,0x82,0x6c,0x92,0x7e,0x51,0x8a,0x68,0x8c,0x72,0x7b,0xb0,0x6b,0x87,
     0x65,0x75,0x74,0x84,0x48,0x9b,0x8e,0x86,0x64,0x84,0x51,0x8b,0xa4,0x6f,0xa7,0xad,0x84,0x91,0x78,0x61,0x79,0xac,0x77,0xab,0x7e,0x79,0x8f,0x90,0x8d,0x9d,0x62,0xb0,0x82,0x85,0x69,0x86,0x60,0xbf,0x7e,0x56,0x7e,0x7c,0x76,0x99,0xae,0x79,0x77,0x84,0x83,0x75,0x79,0xa6,0x6a,0xa6,0x79,0x81,0x87,0x83,0x6d,0x9f,0x7b,0x78,0xa4,0x7c,0x58,0x79,0x7a,0x5f,0x90,0x91,0xa8,0x79,0x68,0x86,0x8f,0x73,0x67,0x91,0x90,0x75,0x7b,0x96,0x50,0x7c,0x92,0x6a,0xa4,0x52,0x5b,0x9f,0x9d,0x97,0x57,0x29,0x92,0x94,0x9b,0x92,0x74,0x80,0xb5,0x49,0xb6,0x8e,0x90,0x6b,0x96,0x95,0x67,0x85,0x57,0x92,0x59,0x80,0x83,0x7a,0x91,0x92,0x6f,0x54,0xa3,0x91,0x9a,0x5c,0x89,0x50,0x4c,0x72,0x50,0x9a,0x64,0x46,0x7b,0x78,0x75,0x84,0x64,0x47,0xa4,0x59,0x74,0x73,0x79,0x84,0x7f,0x56,0x66,0x73,0x9b,0x8a,0x5d,0xa7,0x5f,0x98,0x8d,0x95,0x60,0x60,0x73,0x7a,0x7f,0x79,0x72,0x7b,0x98,0x7b,0x91,0x87,0x76,0x85,0x76,0x88,0x8e,0x5f,0x7c,0x9c,0x8c,0x72,0x6e,0x87,0x85,0x8e,0x92,0xa8,0x96,0x6c,0x99,0x82,0x6e,0x9b,0x6a,0x55,0x60,0x84,0x70,0x53,0x6b,0xa1,0x8d,0x89,0x57,0x76,0x7b,0x8d,0x95,0x8d,0x87,0x6f,0x98,0x9a,0x89,0xa9,0xbe,0x91,0x85,0x90,0xb2,0xbc,0xbb,0x68,0xcb,0x76,0x88,0x92,0x6c,0x66,0x6c,0x85,0x73,0x82,0x5e,0x7f,0x92,0x74,0x89,0x57,0x85,0xa7,0x79,0x87,0x71,0x7e,0x67,0x91,0x5f,0x93,0x6c,0x5b,0xb0,0x54,0x77,0x68,0x52,0x76,0x7e,0x66,
     0x69,0x9e,0x88,0x9d,0x61,0x73,0x7a,0x9e,0x7e,0x88,0xa6,0x85,0x95,0x61,0x5f,0x68,0xa8,0x71,0x5b,0x7c,0x62,0x4f,0x78,0x99,0x67,0x6a,0x85,0x8c,0x4f,0x9e,0x6d,0xa8,0x96,0x8e,0x96,0x93,0x58,0xba,0x62,0x63,0x70,0x70,0x78,0x6c,0x7a,0x8d,0x7b,0xbd,0x6c,0x8f,0x92,0x70,0x53,0x8f,0x68,0x64,0x9d,0x80,0x95,0x4a,0x91,0x8a,0x9b,0xa7,0x9c,0x87,0x69,0x7f,0xa9,0x94,0x7c,0xa1,0x7a,0xa7,0x84,0x78,0x79,0x7a,0xa1,0x7f,0x82,0x59,0x5e,0x6e,0x73,0x98,0x7e,0x98,0x7a,0x86,0x7d,0x92,0x90,0x65,0x6b,0x4c,0x5b,0xc3,0x59,0x86,0x53,0x98,0x97,0x65,0x52,0x88,0x87,0x9c,0x9f,0x75,0xa5,0x75,0x89,0x97,0x62,0x8a,0x7c,0x97,0x8d,0x88,0x98,0x94,0x90,0x78,0x7f,0x82,0x60,0xb4,0x9d,0x68,0x54,0x83,0x97,0x7c,0x48,0x9f,0x82,0xa4,0x5c,0x54,0xb2,0x48,0x61,0xb5,0x93,0x6f,0x7b,0x7f,0x61,0x68,0x8a,0x7b,0x42,0x54,0x7d,0x58,0x6f,0x4d,0x98,0x7d,0xa7,0x7d,0x6b,0x75,0x54,0x70,0x99,0x78,0x5b,0x8c,0xb4,0x9c,0x94,0x74,0x90,0x92,0x80,0x64,0x90,0x75,0xa1,0x62,0xb6,0x7b,0x8a,0x89,0x7b,0x63,0x60,0x72,0x5a,0x8a,0x91,0x6f,0x6e,0x77,0x6a,0x7a,0x58,0x8c,0x6f,0x9d,0x62,0x63,0x7d,0x97,0x64,0x56,0x9a,0xbb,0x89,0xb4,0x7a,0x64,0x8c,0x73,0x80,0x94,0x70,0x8b,0x9d,0x7b,0x98,0x66,0x89,0x79,0x7f,0xaa,0x6b,0x91,0x9a,0x66,0xa1,0x86,0x86,0x72,0x7e,0x9c,0x70,0x90,0x80,0x9a,0x5f,0x83,0x7c,0xa1,0x56,0x5f,0x62,0x8d,0xba,0x7f,0x8e,0x9c,0x79,0x8e,
     0x7b,0xbd,0x8d,0x69,0x40,0x91,0x8e,0xa9,0x71,0x69,0x7e,0x9a,0x70,0x61,0x81,0xa3,0xb7,0x71,0x64,0x86,0x8c,0x59,0x47,0xa0,0x55,0x92,0x7a,0x8f,0x83,0xa4,0x6e,0xae,0x77,0x96,0x74,0x73,0x70,0xa3,0x6c,0x6d,0x80,0x91,0x8f,0x6f,0xa6,0x90,0x8f,0x80,0x65,0x87,0x98,0x88,0x5d,0x86,0x5e,0x8b,0x7f,0x8f,0xa3,0xa5,0x5e,0x8a,0x7b,0x7e,0x8e,0x7c,0x50,0x4d,0x80,0xa8,0x6b,0x7e,0x70,0x8d,0x8e,0x52,0x5e,0x6d,0x92,0x80,0x79,0x6d,0x4a,0x65,0x85,0xbd,0x78,0x85,0x8e,0x86,0x88,0x98,0x7f,0x66,0x77,0x9d,0x63,0x95,0x90,0x78,0x49,0x78,0x73,0x7a,0x91,0xa6,0x8b,0x98,0x8d,0x8d,0x65,0x93,0x9f,0x6c,0x6d,0x7d,0x84,0x97,0x55,0x58,0x7d,0x9e,0x7f,0x6d,0x6f,0x73,0x74,0xa4,0x84,0x89,0x67,0x77,0x8d,0x84,0x83,0x6c,0x5c,0x85,0x6b,0x83,0x7f,0x62,0x83,0x7b,0x85,0x6a,0xa7,0xa6,0x7c,0x7e,0x8a,0xa1,0x55,0x77,0x90,0x6c,0x95,0x6c,0x99,0xa1,0x7b,0x74,0x78,0x68,0x77,0x88,0x91,0x58,0x75,0x99,0x89,0x68,0x9c,0x41,0x84,0x9e,0x69,0x93,0x7a,0x61,0x51,0x6d,0xb0,0x69,0x9e,0x86,0x8f,0x82,0x7a,0x86,0x4f,0x80,0x9a,0x9b,0x6c,0x6a,0x7d,0x7b,0x56,0x61,0x5b,0x68,0x6f,0x80,0x88,0x71,0x8f,0x8e,0x9a,0xb3,0x94,0x94,0x74,0x83,0x9e,0x7f,0x96,0x9c,0x8f,0x79,0xbc,0x93,0x67,0x5f,0x85,0x54,0x8a,0x97,0x65,0x8e,0x86,0xa6,0x86,0x86,0x68,0x6a,0x96,0x7c,0x6c,0x67,0x89,0x8d,0x9a,0xa2,0x64,0xa4,0x7f,0x56,0x58,0x77,0x62,0x5e,0x80,0x9c,0x89,0x9b,
     0x69,0x7c,0xa0,0xb1,0x49,0x90,0x9a,0x97,0x90,0x74,0x76,0x7a,0x86,0x79,0x7d,0x72,0xa2,0x8c,0x77,0x7d,0x86,0x6b,0x7e,0xa5,0x59,0x7a,0x69,0x83,0x6c,0x91,0x77,0x9b,0x78,0x89,0xa4,0x89,0x56,0xac,0x93,0x7e,0x81,0x90,0x60,0x7f,0xa4,0x74,0x89,0xa4,0x8a,0x7a,0x9e,0x79,0x57,0x85,0x97,0x59,0xb0,0x8f,0x92,0x97,0x86,0x93,0x92,0xaa,0x98,0x94,0x3e,0x59,0x7d,0x84,0x91,0x75,0x81,0x98,0x99,0x81,0x7b,0x5c,0x91,0x82,0x70,0x6d,0x61,0x68,0x7e,0xb5,0x8e,0x94,0x8d,0x91,0x99,0x8f,0x77,0x6b,0x95,0x6f,0x70,0xd1,0x80,0x73,0x75,0x80,0x87,0x5d,0x84,0xbc,0x8b,0x94,0x86,0x80,0x8e,0x9f,0x7c,0x83,0x49,0x8a,0x7a,0x99,0x85,0x63,0x89,0xad,0x70,0x64,0x5d,0x86,0x74,0xa9,0x80,0x62,0x7d,0x8e,0xa9,0x8d,0x66,0x88,0x75,0x75,0x6d,0x47,0xa2,0x46,0x7a,0x86,0x95,0x79,0x6e,0x98,0x5b,0x85,0x89,0x85,0x64,0x78,0x95,0x5c,0x6c,0x52,0x78,0x87,0xad,0x9a,0x7e,0x7d,0x76,0x77,0x82,0x75,0x79,0x7e,0x95,0x8f,0x7c,0x4c,0x9b,0x97,0x7b,0x82,0x7a,0x90,0x8c,0x53,0xa2,0x7a,0x77,0x69,0x86,0x6c,0x71,0x7a,0x45,0x87,0x64,0x90,0x7d,0x73,0x71,0x83,0x65,0x90,0x6b,0x6f,0x88,0x70,0x90,0x86,0x6f,0x6f,0x59,0xad,0xa7,0xa6,0x7f,0x6b,0x9e,0x82,0x7b,0xa6,0x91,0x76,0xa5,0x8a,0x8f,0x51,0x62,0x5d,0x88,0x9c,0x53,0x65,0x97,0x72,0x95,0x73,0x63,0x69,0x95,0xad,0x77,0x64,0x61,0xa6,0x79,0xae,0x88,0x9f,0x63,0x57,0x94,0x6c,0xa0,0x70,0x85,0x95,0x7e,0x95,
     0x80,0x71,0x7f,0x6c,0x58,0x99,0x82,0x9a,0x64,0x85,0x5f,0x88,0x99,0x6a,0x79,0x9c,0x81,0x95,0x72,0x7b,0x87,0x8d,0x70,0x97,0x9f,0x7b,0x73,0x97,0x8c,0x7f,0x68,0x94,0x81,0x84,0x90,0x92,0x62,0xa1,0x7d,0x6d,0x66,0x72,0x8f,0x9c,0x99,0x80,0x87,0x95,0x80,0x6b,0x81,0x7c,0x6d,0xac,0x7f,0x88,0xa7,0x92,0x83,0x7f,0x82,0x8c,0x9c,0x7f,0x80,0x6d,0x67,0x67,0x78,0x82,0x91,0x56,0x70,0x8b,0xb1,0x69,0x7e,0x8a,0x93,0x7b,0x69,0x7e,0x63,0x85,0x83,0x82,0x8c,0x71,0x74,0x90,0x9f,0xa9,0x70,0x61,0xa4,0x80,0x79,0xa3,0x71,0x7e,0x80,0x57,0xae,0x90,0xa0,0xa3,0x8b,0x9b,0x6f,0x8a,0x6c,0x90,0x67,0x7c,0x7d,0x83,0x95,0x97,0x8d,0x66,0xb3,0x92,0x93,0x49,0x8c,0x6c,0x69,0x6d,0x60,0x7b,0x65,0x5c,0xa3,0x89,0x89,0x67,0x62,0x3d,0x77,0x60,0x65,0x65,0x5f,0x85,0x9f,0x72,0x83,0x7d,0x8b,0x96,0x46,0x83,0x7c,0x7d,0x93,0x5b,0x70,0x5e,0x82,0x81,0x93,0x86,0x78,0x5c,0x99,0x85,0xa7,0x78,0x51,0x71,0x82,0x7a,0x87,0x5a,0x8f,0x97,0x7b,0x89,0x6c,0x76,0x92,0x8c,0x84,0x98,0x8c,0x7e,0x97,0x72,0x75,0x8f,0x76,0x70,0x6e,0x93,0x79,0x4c,0x7f,0x69,0x83,0x88,0x77,0x65,0x8d,0x7a,0x92,0x82,0x74,0x7b,0x7b,0xa4,0x96,0xa3,0x8a,0x92,0x88,0x7a,0xb2,0xb4,0xad,0x81,0xa8,0x64,0x86,0x7c,0x53,0x6d,0x7e,0x88,0x64,0x58,0x73,0x84,0x9a,0x73,0x8f,0x6e,0x8a,0x7d,0x76,0x86,0x6b,0x6f,0x66,0xa8,0x82,0x89,0x60,0x4f,0xbd,0x7c,0x95,0x59,0x65,0x63,0x77,0x8e,
     0x6e,0x7f,0x5e,0x80,0x4a,0x83,0x77,0x81,0x56,0x6c,0x70,0x93,0x8f,0x6d,0x81,0x78,0xad,0x81,0x49,0x7c,0x81,0x7d,0x6e,0x8c,0x77,0x7c,0x92,0x7d,0x96,0xae,0x98,0xa6,0xa1,0x5b,0x84,0x99,0x7a,0xa3,0x4a,0x51,0x9a,0x79,0x8e,0x74,0x72,0xae,0x84,0xa3,0x59,0x85,0x50,0xb4,0x4a,0xa6,0x92,0x99,0x8b,0x76,0x91,0x5f,0x7d,0x7a,0xa3,0x71,0x6d,0x8f,0x8d,0x71,0x8d,0xa4,0x63,0x82,0x52,0x80,0xa4,0x85,0x7e,0x95,0x82,0x7d,0x86,0x7d,0x5f,0xa7,0x92,0x7e,0x9e,0x73,0x4f,0x56,0x73,0xa4,0x7f,0x78,0x7b,0x83,0x9f,0x91,0x6e,0x83,0x8c,0x60,0x8b,0x75,0x69,0x5f,0x79,0xa8,0x77,0x7d,0x80,0x6d,0x70,0x97,0x8e,0x6e,0x90,0xa7,0x7e,0x87,0x98,0x7d,0xa3,0x60,0x8d,0x6a,0x5f,0x8a,0x8c,0xae,0x6c,0x79,0x73,0x68,0x64,0x73,0x87,0x7a,0x6d,0x88,0x7b,0x92,0x83,0x96,0x99,0x74,0x87,0x68,0x7b,0x7b,0x70,0x8e,0x4d,0x67,0xa0,0x5c,0x50,0x64,0x8f,0x82,0x97,0x71,0x62,0x79,0x92,0x75,0xac,0x9c,0x56,0x9a,0x77,0x76,0xa8,0x7b,0x5a,0x9c,0x82,0x78,0x8e,0x64,0x82,0x8c,0x86,0x97,0x85,0x97,0x99,0x66,0x4b,0x89,0x79,0x64,0x4f,0x73,0x68,0x4a,0x4f,0x6b,0x63,0x84,0x74,0x79,0x91,0x63,0x9c,0x5f,0x6c,0x71,0xaa,0x7d,0x9f,0x9c,0xa4,0x76,0x99,0x78,0xaa,0xa4,0x87,0x69,0x9a,0x93,0x7f,0x82,0x53,0x86,0x8e,0x87,0x63,0xc4,0x7c,0x88,0x83,0x8d,0x66,0x5e,0x9a,0x7e,0x7e,0x7e,0x90,0x6a,0x58,0x8a,0x6b,0x93,0x60,0x65,0x8b,0x6c,0x83,0x70,0x81,0x9a,0x71,0x76,
     0x75,0x8b,0x7b,0x83,0x5b,0x7f,0x9d,0x86,0x80,0x7f,0xa4,0x71,0x78,0x87,0x8a,0x76,0x9b,0x7c,0x7c,0x72,0x87,0x72,0x89,0x86,0x70,0x77,0x75,0x6d,0x82,0x96,0x86,0xa9,0x91,0x7c,0x99,0x84,0x71,0x8a,0x74,0x62,0x8f,0x71,0x67,0x77,0x97,0x9c,0x89,0x8a,0x6f,0x8a,0x87,0x97,0x73,0x83,0x7d,0x7d,0xa2,0x79,0x7f,0x65,0x87,0x7c,0x9a,0x93,0x8c,0xae,0x84,0x84,0x89,0x76,0x7a,0x94,0x5b,0x89,0x7c,0x8c,0x6d,0xab,0x87,0x88,0x8d,0x6a,0x79,0x6b,0x9b,0x88,0x5a,0x68,0x78,0x82,0x7d,0x92,0x7d,0x69,0x86,0x68,0x7f,0x91,0x8a,0x6c,0x73,0x86,0x88,0x6f,0x85,0x8e,0x6b,0x97,0x8c,0x75,0x9b,0x76,0x75,0x89,0x78,0x87,0x69,0x8f,0x80,0x71,0x85,0x80,0x84,0x61,0x8e,0x83,0x77,0x9d,0x70,0x77,0x74,0x98,0x93,0x67,0x75,0x6b,0x77,0x97,0x50,0x8d,0x7e,0x88,0x9a,0xa3,0x7c,0x93,0x87,0x79,0x67,0x75,0x81,0x89,0x56,0x66,0x6a,0x6a,0x4e,0x7b,0x75,0x8e,0x9c,0x65,0x73,0x84,0x70,0x60,0xac,0x9f,0x75,0x87,0x89,0x70,0x8a,0x81,0x82,0x8c,0x97,0x7b,0x80,0x6b,0x78,0x83,0x80,0x7d,0x6b,0x80,0x80,0x70,0x53,0x90,0x57,0x5e,0x82,0x63,0x4b,0x64,0x65,0x75,0x63,0x8c,0x67,0x83,0x82,0x6b,0x95,0x5b,0x8c,0x75,0xb3,0xaf,0xa1,0xa4,0x88,0x5b,0x93,0x80,0x91,0x93,0x84,0x7f,0x9b,0x89,0x77,0x70,0x6b,0x6c,0x82,0x7e,0x72,0x9d,0x7a,0x85,0x86,0x93,0x6d,0x76,0x94,0x9a,0x7e,0x8a,0x74,0x9d,0x5e,0x81,0x87,0xa5,0x74,0x62,0x91,0x6c,0x8d,0x81,0x96,0xa1,0x71,0xa0,
     0x89,0x99,0x74,0x84,0x71,0x6b,0x8e,0x74,0x91,0x71,0x85,0x78,0x6a,0x92,0x74,0x80,0xa9,0x85,0x65,0x66,0x62,0x68,0x76,0x68,0x71,0x70,0x7f,0x7e,0x77,0x90,0x8d,0xa8,0x85,0x8c,0x70,0x87,0x87,0x90,0x70,0x72,0x75,0x86,0x5c,0x73,0x9c,0x87,0x87,0x87,0x59,0x85,0x7f,0x9a,0x7f,0x7c,0x8b,0x8b,0x77,0x90,0x82,0x7b,0x69,0x8c,0x71,0x99,0x7d,0xa3,0x86,0x82,0x90,0x72,0x5f,0xa7,0x6b,0xa1,0x76,0x77,0x7a,0x7e,0x8a,0x71,0x92,0x75,0x7d,0x69,0x97,0xa1,0x8f,0x9c,0x7e,0x87,0x78,0x96,0x82,0x75,0x6e,0x55,0x7b,0x7e,0x94,0x76,0x61,0x6d,0x71,0x6b,0x73,0xa8,0x75,0x98,0x8e,0x75,0x80,0x79,0x99,0x87,0x47,0x7d,0x84,0x87,0x65,0x73,0x95,0x7d,0x9d,0x7b,0x83,0x8c,0x70,0x95,0x73,0x95,0x66,0x97,0x6e,0x70,0x78,0x74,0x84,0xa0,0x70,0x70,0x8b,0x7e,0x96,0x83,0x61,0x72,0x7b,0x90,0x5d,0x85,0x94,0x7d,0x74,0x58,0x81,0x60,0x90,0x7c,0x81,0x85,0x98,0x87,0x6d,0x92,0x77,0x78,0x81,0x8c,0x6e,0x77,0x7a,0x73,0x73,0x83,0x6c,0xb3,0x7f,0x66,0x93,0x88,0x71,0x6d,0x83,0x62,0x7d,0x85,0x80,0x7e,0x8a,0x90,0x68,0x7b,0x7d,0x77,0x6d,0x77,0x79,0x73,0x4d,0x67,0x80,0x89,0x94,0x74,0x7b,0x66,0x8f,0x75,0x91,0x81,0x73,0x7e,0x84,0x82,0x92,0x8c,0x85,0x6e,0x7d,0x6d,0x87,0x87,0x7b,0x75,0x7f,0x76,0x86,0x88,0x7e,0x9a,0x83,0x92,0x7c,0x94,0x5f,0x80,0x97,0x71,0x87,0x7f,0x7e,0xa3,0x8a,0x8f,0x8b,0x96,0x7f,0x69,0x5d,0x87,0x8c,0x84,0x8a,0x9a,0x9a,0x85,
     0x74,0x9c,0x75,0x95,0x5e,0x76,0x87,0x77,0x77,0x72,0x94,0x87,0x94,0x7b,0x7d,0x95,0x8e,0x6d,0x84,0x70,0x82,0x72,0x76,0x61,0x6f,0x66,0x7d,0x65,0x73,0xad,0x71,0xa5,0x85,0xa4,0x79,0x85,0x75,0x83,0x7a,0x68,0x7b,0x93,0x69,0x63,0xa4,0x97,0x80,0x83,0x4c,0xa7,0x79,0x7b,0x85,0x80,0x8c,0x94,0x96,0x89,0x8e,0x8d,0x5a,0x98,0x6f,0xae,0x78,0xa7,0x7e,0x7d,0x9d,0x83,0x75,0x7a,0x7e,0x96,0x7d,0x68,0x78,0x69,0x8e,0x67,0x9c,0x73,0x81,0x7b,0xad,0x93,0x84,0xb5,0x99,0x86,0x6f,0x98,0x69,0x70,0x7d,0x75,0x8d,0x7f,0x91,0x70,0x76,0x69,0x86,0x67,0x6f,0xb1,0x63,0x94,0x8a,0x78,0x7f,0x96,0xa5,0x77,0x3d,0x65,0x6b,0x81,0x71,0x6c,0x93,0x80,0x8b,0x5a,0x79,0x82,0x6b,0x94,0x78,0x81,0x7d,0x8b,0x7c,0x59,0x83,0x8c,0x8d,0xa0,0x54,0x65,0x87,0x7a,0x8d,0x89,0x5f,0x6d,0x84,0x94,0x66,0x74,0x95,0x7c,0x6d,0x63,0x64,0x81,0x7b,0x4d,0x78,0x83,0x7c,0x7a,0x69,0x9f,0x76,0x72,0x9f,0x6c,0x71,0x67,0x78,0x7a,0x6a,0x7d,0x67,0xa7,0x8b,0x82,0x89,0x89,0x76,0x84,0x89,0x65,0x7f,0x8e,0x96,0x7a,0x81,0xb0,0x65,0x82,0x73,0x62,0x6d,0x74,0x8a,0x78,0x5c,0x58,0x84,0x94,0xa1,0x87,0x7c,0x87,0xa1,0x76,0x9d,0x99,0x84,0x8e,0x74,0x6c,0x84,0x8b,0x95,0x7e,0x7f,0x51,0xa6,0x88,0x88,0x72,0x62,0x59,0x70,0x86,0x7e,0xa1,0x7b,0xa1,0x8e,0x7d,0x5c,0x67,0x98,0x7b,0x73,0x7a,0x81,0x8d,0xa7,0x78,0x87,0x94,0x7f,0x7b,0x59,0x8b,0x83,0x85,0x74,0xb1,0x9f,0x8a,
     0x6a,0xba,0x92,0xa2,0x2f,0x78,0x98,0x6c,0x8a,0x5f,0xa8,0x62,0x66,0x9e,0x6d,0x82,0xbf,0x90,0x80,0x81,0x82,0x59,0x73,0x5d,0x4f,0x6f,0x6a,0x4b,0x71,0x82,0x64,0xa5,0x8a,0x89,0x96,0x84,0x6d,0x75,0x4a,0x54,0x86,0x8b,0x65,0x97,0x97,0x80,0x82,0x7e,0x6e,0x8b,0x8b,0x8b,0x8e,0x82,0x70,0x7a,0x7a,0x7d,0x80,0x73,0x75,0x9e,0x6e,0xa8,0x95,0xa7,0x89,0x81,0x9c,0x7d,0x5b,0xb2,0x67,0x9e,0x7c,0x73,0x7d,0xb0,0x70,0x86,0x8b,0x62,0x6c,0x7f,0x87,0x97,0x8a,0x75,0x86,0x81,0x7c,0x9b,0x7a,0x82,0x60,0x68,0x7f,0x83,0xa3,0x7a,0x56,0x72,0x60,0x76,0x7e,0x9c,0x7a,0x9d,0x90,0x8a,0x83,0x84,0x6b,0x8f,0x76,0x8e,0x58,0x7c,0x68,0x64,0x89,0x87,0x8f,0x60,0x75,0x89,0x62,0xb9,0x7a,0x93,0x79,0xa1,0x78,0x71,0x64,0x60,0x90,0x8a,0x4a,0x8a,0x78,0x63,0xb4,0x8a,0x5d,0x7c,0x75,0xb3,0x62,0x86,0x86,0x87,0x63,0x61,0x8f,0x6f,0x58,0x7b,0x82,0x7e,0x8c,0x77,0x6c,0x88,0x7a,0x74,0xa1,0xa4,0x61,0x94,0x6b,0x7f,0x6c,0x7e,0x80,0x95,0x7f,0x82,0x96,0x73,0x61,0x6d,0x80,0x95,0x63,0x7a,0x82,0x91,0x68,0x7f,0x88,0x79,0x75,0x79,0x3a,0x73,0x68,0x7c,0x6f,0x75,0x77,0x90,0x90,0x77,0x88,0x6b,0x8a,0x71,0x95,0x89,0x9d,0x98,0x7b,0x65,0x97,0x7e,0xa9,0x95,0x86,0x7d,0x9b,0x73,0x7a,0x72,0x53,0x67,0x72,0x92,0x7b,0x78,0x83,0x96,0x8b,0x97,0x48,0x7a,0x9b,0x90,0x71,0x94,0x97,0xaa,0x7f,0x86,0x6b,0xc6,0x81,0x69,0x77,0x6a,0xa7,0x63,0x9a,0xb9,0x76,0x9d,
     0x73,0x90,0x82,0xb3,0x70,0x51,0x9b,0x82,0x78,0x6a,0x97,0x89,0xa1,0x96,0x6e,0x8c,0xac,0x8b,0x6e,0x76,0x74,0x76,0x78,0x84,0x7c,0x62,0x60,0x81,0x8a,0x96,0x8b,0x91,0xad,0x86,0x8d,0x86,0x87,0xa9,0x75,0x68,0x6e,0x8a,0x66,0x81,0x91,0x98,0x70,0x9c,0xa9,0x74,0x65,0x8a,0x5b,0x92,0x8e,0x5a,0xa6,0xa9,0x9e,0x82,0x53,0x7e,0x89,0x89,0x72,0x95,0x67,0x7a,0x98,0x67,0x84,0x8e,0x78,0x87,0x82,0x7b,0x6d,0x96,0x98,0xa5,0x8a,0x77,0x6e,0x6d,0x9a,0x96,0x7c,0x79,0x96,0x79,0x7c,0x9f,0x66,0x55,0x87,0x63,0x81,0xaf,0x75,0x67,0x60,0x9d,0x95,0x6b,0x7e,0x8e,0x75,0x88,0x75,0x7f,0xa6,0xa3,0x71,0x9e,0x8e,0x88,0x83,0x6c,0x6d,0x7c,0x8a,0x95,0x8a,0x5d,0x77,0x82,0x5d,0x9f,0x7d,0x88,0x78,0xbf,0x50,0x7a,0x79,0x96,0x9c,0x89,0x5c,0x5c,0x76,0x68,0x94,0x98,0x8c,0x84,0x85,0x8d,0x8a,0x5e,0x93,0x6a,0x5c,0x61,0x73,0x4c,0x6e,0x84,0x6b,0x88,0xa6,0x87,0x56,0xa0,0x62,0x58,0x80,0x8c,0x77,0x78,0x6b,0x76,0x9e,0x7f,0x8a,0x9f,0x98,0x82,0x7b,0x73,0x8a,0x69,0x9c,0x75,0x78,0x8b,0x82,0x5d,0x6a,0x6b,0x5e,0x7b,0x6f,0x75,0x36,0x61,0x74,0x95,0x40,0x8c,0x88,0x67,0xaa,0x70,0x91,0x75,0x99,0x70,0x87,0x95,0x8d,0xa8,0x89,0x64,0xab,0x8e,0x81,0x90,0x50,0x72,0xab,0x87,0x8b,0x54,0x84,0x64,0x93,0x8d,0x74,0x96,0x70,0x64,0x9a,0x75,0x60,0x5c,0xb6,0x97,0x7c,0x6e,0x86,0x9b,0x5d,0x71,0x92,0xa2,0x8d,0x67,0x8b,0x66,0x9c,0x61,0x90,0xa2,0x5d,0x90
 };

  struct cpu_inst_layer_t l = net->layers[net->output_layer[0]];
  uint8_t* self_feature = (uint8_t*) MEM_PTR(l.out_layer_mem, DATA_buf, net->patch_size);

  int feature_length = 256;
  int feature[100][256] = { 0 };
  int min_id = 0;
  int min_value = 0;
  for (int k = 0; k < 12; k++) {
      int square_sum = 0;
      int face_offset = k * feature_length;
      for (int i = 0; i < feature_length; i++) {
          square_sum += (int)(self_feature[i] - feature_list[face_offset + i]) * (int)(self_feature[i] - feature_list[face_offset + i]);
      }
      printf("%s: %d\r\n", face_IDs[k], square_sum);
      if (k == 0) min_value = square_sum;
      else if (square_sum < min_value) {
          min_value = square_sum;
          min_id = k;
      }
  }
  printf("Who are you? %s\r\n", face_IDs[min_id]);
}

