/*
 * This file is part of the OpenMV project.
 * Copyright (c) 2013/2014 Ibrahim Abdelkader <i.abdalkader@gmail.com>
 * This work is licensed under the MIT license, see the file LICENSE for details.
 *
 * OV2640 driver.
 *
 */
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <smart_sensor.h>
#include "sccb.h"
//#include "camera.h"
//#include "bf2013.h"

#define OUT_YUV_MODE 1
static const uint8_t bf2013_reglist[][2] =
{
    //BF2013 YUV
    ////XCLK:24M HZ-->MCLK:24M HZ
    #if OUT_YUV_MODE
    {0x12,0x80},
    {0x67,0x00},
    {0x68,0x00},
    {0xb9, 0x00},//test pattern bypass
    //{0xb9, 0x80},//test pattern enable
    //{0x69,0x20},
    {0x3a,0x00},//YUV422 sequence-YUYV
    {0x09,0x01},
    {0x15,0x02},
    {0x12,0x00},
    #else
        {0x12,0x84},
        {0x09,0x01},
        {0x12,0x04},
        {0xb6,0x00},
        {0xb7,0x00},
        {0xb8,0x00},
        {0xb9, 0xc0},//use Test pattern
        //{0x69,0x20},
        {0x3a,0x12},//RGB565 sequence-R5G3H,G3LB5
    {0x15,0x02},
    #endif
    {0x1a,0x78},    // change win height from 640 to 360

    //{0x1e,0x00},
    {0x1e,0x30},    // enable mirror & flip
    {0x13,0x00},
    {0x01,0x14},
    {0x02,0x21},
    {0x8c,0x02},
    {0x8d,0x64},
    {0x87,0x18},
    {0x13,0x07},
    {0x11,0x80},
    {0x2b,0x20},
    {0x92,0x40},
    {0x9d,0x99},
    {0x06,0xe0},
    {0x29,0x54},
    {0xeb,0x30},
    {0xbb,0x20},
    {0xf5,0x21},
    {0xe1,0x3c},
    {0x16,0x01},
    {0xe0,0x0b},
    {0x2f,0xf6},
    {0x33,0x20},
    {0x34,0x08},
    {0x35,0x50},
    {0x65,0x4a},
    {0x66,0x50},
    {0x36,0x05},
    {0x37,0xf6},
    {0x38,0x46},
    {0x9b,0xf6},
    {0x9c,0x46},
    {0xbc,0x01},
    {0xbd,0xf6},
    {0xbe,0x46},
    {0x82,0x14},
    {0x83,0x23},
    {0x9a,0x23},
    {0x70,0x6f},
    {0x72,0x3f},
    {0x73,0x3f},
    {0x74,0x27},
    {0x77,0x90},
    {0x79,0x48},
    {0x7a,0x1e},
    {0x7b,0x30},
    {0x84,0x1a},
    {0x85,0x20},
    {0x89,0x02},
    {0x8a,0x64},
    {0x86,0x30},
    {0x96,0xa6},
    {0x97,0x0c},
    {0x98,0x18},
    {0x80,0x55},
    {0x24,0x70},
    {0x25,0x80},
    {0x94,0x0a},
    {0x1f,0x20},
    {0x22,0x20},
    {0x26,0x20},
    {0x56,0x40},
    {0x61,0xd3},
    {0x79,0x48},
    {0x3b,0x60},
    {0x3c,0x20},
    {0x39,0x80},
    {0x3f,0xb0},
    {0x39,0x80},
    {0x40,0x58},
    {0x41,0x54},
    {0x42,0x4e},
    {0x43,0x44},
    {0x44,0x3e},
    {0x45,0x39},
    {0x46,0x35},
    {0x47,0x31},
    {0x48,0x2e},
    {0x49,0x2b},
    {0x4b,0x29},
    {0x4c,0x27},
    {0x4e,0x23},
    {0x4f,0x20},
    {0x50,0x1e},
    {0x51,0x05},
    {0x52,0x10},
    {0x53,0x0b},
    {0x54,0x15},
    {0x57,0x87},
    {0x58,0x72},
    {0x59,0x5f},
    {0x5a,0x7e},
    {0x5b,0x1f},
    {0x5c,0x0e},
    {0x5d,0x95},
    {0x60,0x28},
    {0xb0,0xe0},
    {0xb1,0xc0},
    {0xb2,0xb0},
    {0xb3,0x88},
    {0x6a,0x01},
    {0x23,0x66},
    {0xa0,0x03},
    {0xa1,0x31},
    {0xa2,0x0b},
    {0xa3,0x26},
    {0xa4,0x05},
    {0xa5,0x25},
    {0xa6,0x06},
    {0xa7,0x80},
    {0xa8,0x80},
    {0xa9,0x20},
    {0xaa,0x20},
    {0xab,0x20},
    {0xac,0x3c},
    {0xad,0xf0},
    {0xc8,0x18},
    {0xc9,0x20},
    {0xca,0x17},
    {0xcb,0x1f},
    {0xaf,0x00},
    {0xc5,0x18},
    {0xc6,0x00},
    {0xc7,0x20},
    {0xae,0x80},
    {0xcc,0x40},
    {0xcd,0x58},
    {0xee,0x4c},
#if 0
    {0x8e,0x07},
    {0x8f,0x79},
#else   // limit longest exposure time to keep 25 fps
    {0x8e,0x01},
    {0x8f,0xcb},
#endif
};

//TODO use data section
//static const uint8_t addr_list[] =
//{
//    0x6e
//};

#define BF2013_ADDR 0x6e
#define BF_ID_MSB 0x37
#define BF_ID_LSB 0x03

int bf2013_probe(void)
{
    printf("------------------bf2013_probe---------------\r\n");
    uint8_t id_msb = 0, id_lsb = 0;
    SCCB_Read(BF2013_ADDR, 0xfc, &id_msb);
    printf("------------------%02x \r\n", id_msb);
    SCCB_Read(BF2013_ADDR, 0xfd, &id_lsb);
    printf("------------------%02x \r\n", id_lsb);

    if(BF_ID_MSB == id_msb && BF_ID_LSB == id_lsb)
        return 0;
    else
        return -1;
}

int bf2013_reset(smart_sensor_t *sensor)
{
    int i, ret;

    printf("------------------bf2013_reset---------------\r\n");
    for (i = 0; i < sizeof(bf2013_reglist)/sizeof(bf2013_reglist[0]); i++) {
        ret = SCCB_Write(BF2013_ADDR, bf2013_reglist[i][0], bf2013_reglist[i][1]);
        vTaskDelay(1);
        printf("[BF2013] 0x%x = 0x%x, ret %d\r\n", bf2013_reglist[i][0], bf2013_reglist[i][1], ret);
    }
    return 0;
}

//  const rt_camera_desc __rt_camera_bf2013_desc __attribute__((section(".camera_desc"))) =
//  {
//      .name = "__rti_name_bf2013",
//      .addr = BF2013_ADDR,
//      .frm_vld_high = 1,
//      .probe = bf2013_probe,
//      .reset = bf2013_reset,
//      .width = 640,
//      .height = 360,
//  };

const BL_SENSOR_DESC_T sensor_desc_bf2013 ATTR_SENSOR_DEVICE_TABLE =
{
	"BF2013",
	BF2013_ADDR,
	bf2013_probe,
	bf2013_reset,
    NULL,
};
