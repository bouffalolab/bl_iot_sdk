<html lang="en">
<head>
<title>PowerPC Built-in Functions - Using the GNU Compiler Collection (GCC)</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Using the GNU Compiler Collection (GCC)">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Target-Builtins.html#Target-Builtins" title="Target Builtins">
<link rel="prev" href="picoChip-Built_002din-Functions.html#picoChip-Built_002din-Functions" title="picoChip Built-in Functions">
<link rel="next" href="PowerPC-AltiVec_002fVSX-Built_002din-Functions.html#PowerPC-AltiVec_002fVSX-Built_002din-Functions" title="PowerPC AltiVec/VSX Built-in Functions">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 1988-2018 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``Funding Free Software'', the Front-Cover
Texts being (a) (see below), and with the Back-Cover Texts being (b)
(see below).  A copy of the license is included in the section entitled
``GNU Free Documentation License''.

(a) The FSF's Front-Cover Text is:

     A GNU Manual

(b) The FSF's Back-Cover Text is:

     You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="PowerPC-Built-in-Functions"></a>
<a name="PowerPC-Built_002din-Functions"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="PowerPC-AltiVec_002fVSX-Built_002din-Functions.html#PowerPC-AltiVec_002fVSX-Built_002din-Functions">PowerPC AltiVec/VSX Built-in Functions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="picoChip-Built_002din-Functions.html#picoChip-Built_002din-Functions">picoChip Built-in Functions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Target-Builtins.html#Target-Builtins">Target Builtins</a>
<hr>
</div>

<h4 class="subsection">6.59.21 PowerPC Built-in Functions</h4>

<p>The following built-in functions are always available and can be used to
check the PowerPC target platform type:

<div class="defun">
&mdash; Built-in Function: void <b>__builtin_cpu_init</b> (<var>void</var>)<var><a name="index-g_t_005f_005fbuiltin_005fcpu_005finit-4676"></a></var><br>
<blockquote><p>This function is a <code>nop</code> on the PowerPC platform and is included solely
to maintain API compatibility with the x86 builtins. 
</p></blockquote></div>

<div class="defun">
&mdash; Built-in Function: int <b>__builtin_cpu_is</b> (<var>const char *cpuname</var>)<var><a name="index-g_t_005f_005fbuiltin_005fcpu_005fis-4677"></a></var><br>
<blockquote><p>This function returns a value of <code>1</code> if the run-time CPU is of type
<var>cpuname</var> and returns <code>0</code> otherwise

      <p>The <code>__builtin_cpu_is</code> function requires GLIBC 2.23 or newer
which exports the hardware capability bits.  GCC defines the macro
<code>__BUILTIN_CPU_SUPPORTS__</code> if the <code>__builtin_cpu_supports</code>
built-in function is fully supported.

      <p>If GCC was configured to use a GLIBC before 2.23, the built-in
function <code>__builtin_cpu_is</code> always returns a 0 and the compiler
issues a warning.

      <p>The following CPU names can be detected:

          <dl>
<dt>&lsquo;<samp><span class="samp">power9</span></samp>&rsquo;<dd>IBM POWER9 Server CPU. 
<br><dt>&lsquo;<samp><span class="samp">power8</span></samp>&rsquo;<dd>IBM POWER8 Server CPU. 
<br><dt>&lsquo;<samp><span class="samp">power7</span></samp>&rsquo;<dd>IBM POWER7 Server CPU. 
<br><dt>&lsquo;<samp><span class="samp">power6x</span></samp>&rsquo;<dd>IBM POWER6 Server CPU (RAW mode). 
<br><dt>&lsquo;<samp><span class="samp">power6</span></samp>&rsquo;<dd>IBM POWER6 Server CPU (Architected mode). 
<br><dt>&lsquo;<samp><span class="samp">power5+</span></samp>&rsquo;<dd>IBM POWER5+ Server CPU. 
<br><dt>&lsquo;<samp><span class="samp">power5</span></samp>&rsquo;<dd>IBM POWER5 Server CPU. 
<br><dt>&lsquo;<samp><span class="samp">ppc970</span></samp>&rsquo;<dd>IBM 970 Server CPU (ie, Apple G5). 
<br><dt>&lsquo;<samp><span class="samp">power4</span></samp>&rsquo;<dd>IBM POWER4 Server CPU. 
<br><dt>&lsquo;<samp><span class="samp">ppca2</span></samp>&rsquo;<dd>IBM A2 64-bit Embedded CPU
<br><dt>&lsquo;<samp><span class="samp">ppc476</span></samp>&rsquo;<dd>IBM PowerPC 476FP 32-bit Embedded CPU. 
<br><dt>&lsquo;<samp><span class="samp">ppc464</span></samp>&rsquo;<dd>IBM PowerPC 464 32-bit Embedded CPU. 
<br><dt>&lsquo;<samp><span class="samp">ppc440</span></samp>&rsquo;<dd>PowerPC 440 32-bit Embedded CPU. 
<br><dt>&lsquo;<samp><span class="samp">ppc405</span></samp>&rsquo;<dd>PowerPC 405 32-bit Embedded CPU. 
<br><dt>&lsquo;<samp><span class="samp">ppc-cell-be</span></samp>&rsquo;<dd>IBM PowerPC Cell Broadband Engine Architecture CPU. 
</dl>

      <p>Here is an example:
     <pre class="smallexample">          #ifdef __BUILTIN_CPU_SUPPORTS__
            if (__builtin_cpu_is ("power8"))
              {
                 do_power8 (); // POWER8 specific implementation.
              }
            else
          #endif
              {
                 do_generic (); // Generic implementation.
              }
</pre>
      </blockquote></div>

<div class="defun">
&mdash; Built-in Function: int <b>__builtin_cpu_supports</b> (<var>const char *feature</var>)<var><a name="index-g_t_005f_005fbuiltin_005fcpu_005fsupports-4678"></a></var><br>
<blockquote><p>This function returns a value of <code>1</code> if the run-time CPU supports the HWCAP
feature <var>feature</var> and returns <code>0</code> otherwise.

      <p>The <code>__builtin_cpu_supports</code> function requires GLIBC 2.23 or
newer which exports the hardware capability bits.  GCC defines the
macro <code>__BUILTIN_CPU_SUPPORTS__</code> if the
<code>__builtin_cpu_supports</code> built-in function is fully supported.

      <p>If GCC was configured to use a GLIBC before 2.23, the built-in
function <code>__builtin_cpu_suports</code> always returns a 0 and the
compiler issues a warning.

      <p>The following features can be
detected:

          <dl>
<dt>&lsquo;<samp><span class="samp">4xxmac</span></samp>&rsquo;<dd>4xx CPU has a Multiply Accumulator. 
<br><dt>&lsquo;<samp><span class="samp">altivec</span></samp>&rsquo;<dd>CPU has a SIMD/Vector Unit. 
<br><dt>&lsquo;<samp><span class="samp">arch_2_05</span></samp>&rsquo;<dd>CPU supports ISA 2.05 (eg, POWER6)
<br><dt>&lsquo;<samp><span class="samp">arch_2_06</span></samp>&rsquo;<dd>CPU supports ISA 2.06 (eg, POWER7)
<br><dt>&lsquo;<samp><span class="samp">arch_2_07</span></samp>&rsquo;<dd>CPU supports ISA 2.07 (eg, POWER8)
<br><dt>&lsquo;<samp><span class="samp">arch_3_00</span></samp>&rsquo;<dd>CPU supports ISA 3.0 (eg, POWER9)
<br><dt>&lsquo;<samp><span class="samp">archpmu</span></samp>&rsquo;<dd>CPU supports the set of compatible performance monitoring events. 
<br><dt>&lsquo;<samp><span class="samp">booke</span></samp>&rsquo;<dd>CPU supports the Embedded ISA category. 
<br><dt>&lsquo;<samp><span class="samp">cellbe</span></samp>&rsquo;<dd>CPU has a CELL broadband engine. 
<br><dt>&lsquo;<samp><span class="samp">dfp</span></samp>&rsquo;<dd>CPU has a decimal floating point unit. 
<br><dt>&lsquo;<samp><span class="samp">dscr</span></samp>&rsquo;<dd>CPU supports the data stream control register. 
<br><dt>&lsquo;<samp><span class="samp">ebb</span></samp>&rsquo;<dd>CPU supports event base branching. 
<br><dt>&lsquo;<samp><span class="samp">efpdouble</span></samp>&rsquo;<dd>CPU has a SPE double precision floating point unit. 
<br><dt>&lsquo;<samp><span class="samp">efpsingle</span></samp>&rsquo;<dd>CPU has a SPE single precision floating point unit. 
<br><dt>&lsquo;<samp><span class="samp">fpu</span></samp>&rsquo;<dd>CPU has a floating point unit. 
<br><dt>&lsquo;<samp><span class="samp">htm</span></samp>&rsquo;<dd>CPU has hardware transaction memory instructions. 
<br><dt>&lsquo;<samp><span class="samp">htm-nosc</span></samp>&rsquo;<dd>Kernel aborts hardware transactions when a syscall is made. 
<br><dt>&lsquo;<samp><span class="samp">ic_snoop</span></samp>&rsquo;<dd>CPU supports icache snooping capabilities. 
<br><dt>&lsquo;<samp><span class="samp">ieee128</span></samp>&rsquo;<dd>CPU supports 128-bit IEEE binary floating point instructions. 
<br><dt>&lsquo;<samp><span class="samp">isel</span></samp>&rsquo;<dd>CPU supports the integer select instruction. 
<br><dt>&lsquo;<samp><span class="samp">mmu</span></samp>&rsquo;<dd>CPU has a memory management unit. 
<br><dt>&lsquo;<samp><span class="samp">notb</span></samp>&rsquo;<dd>CPU does not have a timebase (eg, 601 and 403gx). 
<br><dt>&lsquo;<samp><span class="samp">pa6t</span></samp>&rsquo;<dd>CPU supports the PA Semi 6T CORE ISA. 
<br><dt>&lsquo;<samp><span class="samp">power4</span></samp>&rsquo;<dd>CPU supports ISA 2.00 (eg, POWER4)
<br><dt>&lsquo;<samp><span class="samp">power5</span></samp>&rsquo;<dd>CPU supports ISA 2.02 (eg, POWER5)
<br><dt>&lsquo;<samp><span class="samp">power5+</span></samp>&rsquo;<dd>CPU supports ISA 2.03 (eg, POWER5+)
<br><dt>&lsquo;<samp><span class="samp">power6x</span></samp>&rsquo;<dd>CPU supports ISA 2.05 (eg, POWER6) extended opcodes mffgpr and mftgpr. 
<br><dt>&lsquo;<samp><span class="samp">ppc32</span></samp>&rsquo;<dd>CPU supports 32-bit mode execution. 
<br><dt>&lsquo;<samp><span class="samp">ppc601</span></samp>&rsquo;<dd>CPU supports the old POWER ISA (eg, 601)
<br><dt>&lsquo;<samp><span class="samp">ppc64</span></samp>&rsquo;<dd>CPU supports 64-bit mode execution. 
<br><dt>&lsquo;<samp><span class="samp">ppcle</span></samp>&rsquo;<dd>CPU supports a little-endian mode that uses address swizzling. 
<br><dt>&lsquo;<samp><span class="samp">smt</span></samp>&rsquo;<dd>CPU support simultaneous multi-threading. 
<br><dt>&lsquo;<samp><span class="samp">spe</span></samp>&rsquo;<dd>CPU has a signal processing extension unit. 
<br><dt>&lsquo;<samp><span class="samp">tar</span></samp>&rsquo;<dd>CPU supports the target address register. 
<br><dt>&lsquo;<samp><span class="samp">true_le</span></samp>&rsquo;<dd>CPU supports true little-endian mode. 
<br><dt>&lsquo;<samp><span class="samp">ucache</span></samp>&rsquo;<dd>CPU has unified I/D cache. 
<br><dt>&lsquo;<samp><span class="samp">vcrypto</span></samp>&rsquo;<dd>CPU supports the vector cryptography instructions. 
<br><dt>&lsquo;<samp><span class="samp">vsx</span></samp>&rsquo;<dd>CPU supports the vector-scalar extension. 
</dl>

      <p>Here is an example:
     <pre class="smallexample">          #ifdef __BUILTIN_CPU_SUPPORTS__
            if (__builtin_cpu_supports ("fpu"))
              {
                 asm("fadd %0,%1,%2" : "=d"(dst) : "d"(src1), "d"(src2));
              }
            else
          #endif
              {
                 dst = __fadd (src1, src2); // Software FP addition function.
              }
</pre>
      </blockquote></div>

 <p>These built-in functions are available for the PowerPC family of
processors:
<pre class="smallexample">     float __builtin_recipdivf (float, float);
     float __builtin_rsqrtf (float);
     double __builtin_recipdiv (double, double);
     double __builtin_rsqrt (double);
     uint64_t __builtin_ppc_get_timebase ();
     unsigned long __builtin_ppc_mftb ();
     double __builtin_unpack_longdouble (long double, int);
     long double __builtin_pack_longdouble (double, double);
     __ibm128 __builtin_unpack_ibm128 (__ibm128, int);
     __ibm128 __builtin_pack_ibm128 (double, double);
</pre>
 <p>The <code>vec_rsqrt</code>, <code>__builtin_rsqrt</code>, and
<code>__builtin_rsqrtf</code> functions generate multiple instructions to
implement the reciprocal sqrt functionality using reciprocal sqrt
estimate instructions.

 <p>The <code>__builtin_recipdiv</code>, and <code>__builtin_recipdivf</code>
functions generate multiple instructions to implement division using
the reciprocal estimate instructions.

 <p>The <code>__builtin_ppc_get_timebase</code> and <code>__builtin_ppc_mftb</code>
functions generate instructions to read the Time Base Register.  The
<code>__builtin_ppc_get_timebase</code> function may generate multiple
instructions and always returns the 64 bits of the Time Base Register. 
The <code>__builtin_ppc_mftb</code> function always generates one instruction and
returns the Time Base Register value as an unsigned long, throwing away
the most significant word on 32-bit environments.

 <p>The <code>__builtin_unpack_longdouble</code> function takes a
<code>long double</code> argument and a compile time constant of 0 or 1.  If
the constant is 0, the first <code>double</code> within the
<code>long double</code> is returned, otherwise the second <code>double</code>
is returned.  The <code>__builtin_unpack_longdouble</code> function is only
availble if <code>long double</code> uses the IBM extended double
representation.

 <p>The <code>__builtin_pack_longdouble</code> function takes two <code>double</code>
arguments and returns a <code>long double</code> value that combines the two
arguments.  The <code>__builtin_pack_longdouble</code> function is only
availble if <code>long double</code> uses the IBM extended double
representation.

 <p>The <code>__builtin_unpack_ibm128</code> function takes a <code>__ibm128</code>
argument and a compile time constant of 0 or 1.  If the constant is 0,
the first <code>double</code> within the <code>__ibm128</code> is returned,
otherwise the second <code>double</code> is returned.

 <p>The <code>__builtin_pack_ibm128</code> function takes two <code>double</code>
arguments and returns a <code>__ibm128</code> value that combines the two
arguments.

 <p>Additional built-in functions are available for the 64-bit PowerPC
family of processors, for efficient use of 128-bit floating point
(<code>__float128</code>) values.

 <p>Previous versions of GCC supported some 'q' builtins for IEEE 128-bit
floating point.  These functions are now mapped into the equivalent
'f128' builtin functions.

<pre class="smallexample">     __builtin_fabsq is mapped into __builtin_fabsf128
     __builtin_copysignq is mapped into __builtin_copysignf128
     __builtin_infq is mapped into __builtin_inff128
     __builtin_huge_valq is mapped into __builtin_huge_valf128
     __builtin_nanq is mapped into __builtin_nanf128
     __builtin_nansq is mapped into __builtin_nansf128
</pre>
 <p>The following built-in functions are available on Linux 64-bit systems
that use the ISA 3.0 instruction set.

     <dl>
<dt><code>__float128 __builtin_sqrtf128 (__float128)</code><dd>Perform a 128-bit IEEE floating point square root operation. 
<a name="index-g_t_005f_005fbuiltin_005fsqrtf128-4679"></a>
<br><dt><code>__float128 __builtin_fmaf128 (__float128, __float128, __float128)</code><dd>Perform a 128-bit IEEE floating point fused multiply and add operation. 
<a name="index-g_t_005f_005fbuiltin_005ffmaf128-4680"></a>
<br><dt><code>__float128 __builtin_addf128_round_to_odd (__float128, __float128)</code><dd>Perform a 128-bit IEEE floating point add using round to odd as the
rounding mode. 
<a name="index-g_t_005f_005fbuiltin_005faddf128_005fround_005fto_005fodd-4681"></a>
<br><dt><code>__float128 __builtin_subf128_round_to_odd (__float128, __float128)</code><dd>Perform a 128-bit IEEE floating point subtract using round to odd as
the rounding mode. 
<a name="index-g_t_005f_005fbuiltin_005fsubf128_005fround_005fto_005fodd-4682"></a>
<br><dt><code>__float128 __builtin_mulf128_round_to_odd (__float128, __float128)</code><dd>Perform a 128-bit IEEE floating point multiply using round to odd as
the rounding mode. 
<a name="index-g_t_005f_005fbuiltin_005fmulf128_005fround_005fto_005fodd-4683"></a>
<br><dt><code>__float128 __builtin_divf128_round_to_odd (__float128, __float128)</code><dd>Perform a 128-bit IEEE floating point divide using round to odd as
the rounding mode. 
<a name="index-g_t_005f_005fbuiltin_005fdivf128_005fround_005fto_005fodd-4684"></a>
<br><dt><code>__float128 __builtin_sqrtf128_round_to_odd (__float128)</code><dd>Perform a 128-bit IEEE floating point square root using round to odd
as the rounding mode. 
<a name="index-g_t_005f_005fbuiltin_005fsqrtf128_005fround_005fto_005fodd-4685"></a>
<br><dt><code>__float128 __builtin_fmaf128 (__float128, __float128, __float128)</code><dd>Perform a 128-bit IEEE floating point fused multiply and add operation
using round to odd as the rounding mode. 
<a name="index-g_t_005f_005fbuiltin_005ffmaf128_005fround_005fto_005fodd-4686"></a>
<br><dt><code>double __builtin_truncf128_round_to_odd (__float128)</code><dd>Convert a 128-bit IEEE floating point value to <code>double</code> using
round to odd as the rounding mode. 
<a name="index-g_t_005f_005fbuiltin_005ftruncf128_005fround_005fto_005fodd-4687"></a></dl>

 <p>The following built-in functions are available for the PowerPC family
of processors, starting with ISA 2.05 or later (<samp><span class="option">-mcpu=power6</span></samp>
or <samp><span class="option">-mcmpb</span></samp>):
<pre class="smallexample">     unsigned long long __builtin_cmpb (unsigned long long int, unsigned long long int);
     unsigned int __builtin_cmpb (unsigned int, unsigned int);
</pre>
 <p>The <code>__builtin_cmpb</code> function
performs a byte-wise compare on the contents of its two arguments,
returning the result of the byte-wise comparison as the returned
value.  For each byte comparison, the corresponding byte of the return
value holds 0xff if the input bytes are equal and 0 if the input bytes
are not equal.  If either of the arguments to this built-in function
is wider than 32 bits, the function call expands into the form that
expects <code>unsigned long long int</code> arguments
which is only available on 64-bit targets.

 <p>The following built-in functions are available for the PowerPC family
of processors, starting with ISA 2.06 or later (<samp><span class="option">-mcpu=power7</span></samp>
or <samp><span class="option">-mpopcntd</span></samp>):
<pre class="smallexample">     long __builtin_bpermd (long, long);
     int __builtin_divwe (int, int);
     unsigned int __builtin_divweu (unsigned int, unsigned int);
     long __builtin_divde (long, long);
     unsigned long __builtin_divdeu (unsigned long, unsigned long);
     unsigned int cdtbcd (unsigned int);
     unsigned int cbcdtd (unsigned int);
     unsigned int addg6s (unsigned int, unsigned int);
     void __builtin_rs6000_speculation_barrier (void);
</pre>
 <p>The <code>__builtin_divde</code> and <code>__builtin_divdeu</code> functions
require a 64-bit environment supporting ISA 2.06 or later.

 <p>The following built-in functions are available for the PowerPC family
of processors, starting with ISA 3.0 or later (<samp><span class="option">-mcpu=power9</span></samp>):
<pre class="smallexample">     long long __builtin_darn (void);
     long long __builtin_darn_raw (void);
     int __builtin_darn_32 (void);
     
     unsigned int scalar_extract_exp (double source);
     unsigned long long int scalar_extract_exp (__ieee128 source);
     
     unsigned long long int scalar_extract_sig (double source);
     unsigned __int128 scalar_extract_sig (__ieee128 source);
     
     double
     scalar_insert_exp (unsigned long long int significand, unsigned long long int exponent);
     double
     scalar_insert_exp (double significand, unsigned long long int exponent);
     
     ieee_128
     scalar_insert_exp (unsigned __int128 significand, unsigned long long int exponent);
     ieee_128
     scalar_insert_exp (ieee_128 significand, unsigned long long int exponent);
     
     int scalar_cmp_exp_gt (double arg1, double arg2);
     int scalar_cmp_exp_lt (double arg1, double arg2);
     int scalar_cmp_exp_eq (double arg1, double arg2);
     int scalar_cmp_exp_unordered (double arg1, double arg2);
     
     bool scalar_test_data_class (float source, const int condition);
     bool scalar_test_data_class (double source, const int condition);
     bool scalar_test_data_class (__ieee128 source, const int condition);
     
     bool scalar_test_neg (float source);
     bool scalar_test_neg (double source);
     bool scalar_test_neg (__ieee128 source);
     
     int __builtin_byte_in_set (unsigned char u, unsigned long long set);
     int __builtin_byte_in_range (unsigned char u, unsigned int range);
     int __builtin_byte_in_either_range (unsigned char u, unsigned int ranges);
     
     int __builtin_dfp_dtstsfi_lt (unsigned int comparison, _Decimal64 value);
     int __builtin_dfp_dtstsfi_lt (unsigned int comparison, _Decimal128 value);
     int __builtin_dfp_dtstsfi_lt_dd (unsigned int comparison, _Decimal64 value);
     int __builtin_dfp_dtstsfi_lt_td (unsigned int comparison, _Decimal128 value);
     
     int __builtin_dfp_dtstsfi_gt (unsigned int comparison, _Decimal64 value);
     int __builtin_dfp_dtstsfi_gt (unsigned int comparison, _Decimal128 value);
     int __builtin_dfp_dtstsfi_gt_dd (unsigned int comparison, _Decimal64 value);
     int __builtin_dfp_dtstsfi_gt_td (unsigned int comparison, _Decimal128 value);
     
     int __builtin_dfp_dtstsfi_eq (unsigned int comparison, _Decimal64 value);
     int __builtin_dfp_dtstsfi_eq (unsigned int comparison, _Decimal128 value);
     int __builtin_dfp_dtstsfi_eq_dd (unsigned int comparison, _Decimal64 value);
     int __builtin_dfp_dtstsfi_eq_td (unsigned int comparison, _Decimal128 value);
     
     int __builtin_dfp_dtstsfi_ov (unsigned int comparison, _Decimal64 value);
     int __builtin_dfp_dtstsfi_ov (unsigned int comparison, _Decimal128 value);
     int __builtin_dfp_dtstsfi_ov_dd (unsigned int comparison, _Decimal64 value);
     int __builtin_dfp_dtstsfi_ov_td (unsigned int comparison, _Decimal128 value);
</pre>
 <p>The <code>__builtin_darn</code> and <code>__builtin_darn_raw</code>
functions require a
64-bit environment supporting ISA 3.0 or later. 
The <code>__builtin_darn</code> function provides a 64-bit conditioned
random number.  The <code>__builtin_darn_raw</code> function provides a
64-bit raw random number.  The <code>__builtin_darn_32</code> function
provides a 32-bit random number.

 <p>The <code>scalar_extract_exp</code> and <code>scalar_extract_sig</code>
functions require a 64-bit environment supporting ISA 3.0 or later. 
The <code>scalar_extract_exp</code> and <code>scalar_extract_sig</code> built-in
functions return the significand and the biased exponent value
respectively of their <code>source</code> arguments. 
When supplied with a 64-bit <code>source</code> argument, the
result returned by <code>scalar_extract_sig</code> has
the <code>0x0010000000000000</code> bit set if the
function's <code>source</code> argument is in normalized form. 
Otherwise, this bit is set to 0. 
When supplied with a 128-bit <code>source</code> argument, the
<code>0x00010000000000000000000000000000</code> bit of the result is
treated similarly. 
Note that the sign of the significand is not represented in the result
returned from the <code>scalar_extract_sig</code> function.  Use the
<code>scalar_test_neg</code> function to test the sign of its <code>double</code>
argument.

 <p>The <code>scalar_insert_exp</code>
functions require a 64-bit environment supporting ISA 3.0 or later. 
When supplied with a 64-bit first argument, the
<code>scalar_insert_exp</code> built-in function returns a double-precision
floating point value that is constructed by assembling the values of its
<code>significand</code> and <code>exponent</code> arguments.  The sign of the
result is copied from the most significant bit of the
<code>significand</code> argument.  The significand and exponent components
of the result are composed of the least significant 11 bits of the
<code>exponent</code> argument and the least significant 52 bits of the
<code>significand</code> argument respectively.

 <p>When supplied with a 128-bit first argument, the
<code>scalar_insert_exp</code> built-in function returns a quad-precision
ieee floating point value.  The sign bit of the result is copied from
the most significant bit of the <code>significand</code> argument. 
The significand and exponent components of the result are composed of
the least significant 15 bits of the <code>exponent</code> argument and the
least significant 112 bits of the <code>significand</code> argument respectively.

 <p>The <code>scalar_cmp_exp_gt</code>, <code>scalar_cmp_exp_lt</code>,
<code>scalar_cmp_exp_eq</code>, and <code>scalar_cmp_exp_unordered</code> built-in
functions return a non-zero value if <code>arg1</code> is greater than, less
than, equal to, or not comparable to <code>arg2</code> respectively.  The
arguments are not comparable if one or the other equals NaN (not a
number).

 <p>The <code>scalar_test_data_class</code> built-in function returns 1
if any of the condition tests enabled by the value of the
<code>condition</code> variable are true, and 0 otherwise.  The
<code>condition</code> argument must be a compile-time constant integer with
value not exceeding 127.  The
<code>condition</code> argument is encoded as a bitmask with each bit
enabling the testing of a different condition, as characterized by the
following:
<pre class="smallexample">     0x40    Test for NaN
     0x20    Test for +Infinity
     0x10    Test for -Infinity
     0x08    Test for +Zero
     0x04    Test for -Zero
     0x02    Test for +Denormal
     0x01    Test for -Denormal
</pre>
 <p>The <code>scalar_test_neg</code> built-in function returns 1 if its
<code>source</code> argument holds a negative value, 0 otherwise.

 <p>The <code>__builtin_byte_in_set</code> function requires a
64-bit environment supporting ISA 3.0 or later.  This function returns
a non-zero value if and only if its <code>u</code> argument exactly equals one of
the eight bytes contained within its 64-bit <code>set</code> argument.

 <p>The <code>__builtin_byte_in_range</code> and
<code>__builtin_byte_in_either_range</code> require an environment
supporting ISA 3.0 or later.  For these two functions, the
<code>range</code> argument is encoded as 4 bytes, organized as
<code>hi_1:lo_1:hi_2:lo_2</code>. 
The <code>__builtin_byte_in_range</code> function returns a
non-zero value if and only if its <code>u</code> argument is within the
range bounded between <code>lo_2</code> and <code>hi_2</code> inclusive. 
The <code>__builtin_byte_in_either_range</code> function returns non-zero if
and only if its <code>u</code> argument is within either the range bounded
between <code>lo_1</code> and <code>hi_1</code> inclusive or the range bounded
between <code>lo_2</code> and <code>hi_2</code> inclusive.

 <p>The <code>__builtin_dfp_dtstsfi_lt</code> function returns a non-zero value
if and only if the number of signficant digits of its <code>value</code> argument
is less than its <code>comparison</code> argument.  The
<code>__builtin_dfp_dtstsfi_lt_dd</code> and
<code>__builtin_dfp_dtstsfi_lt_td</code> functions behave similarly, but
require that the type of the <code>value</code> argument be
<code>__Decimal64</code> and <code>__Decimal128</code> respectively.

 <p>The <code>__builtin_dfp_dtstsfi_gt</code> function returns a non-zero value
if and only if the number of signficant digits of its <code>value</code> argument
is greater than its <code>comparison</code> argument.  The
<code>__builtin_dfp_dtstsfi_gt_dd</code> and
<code>__builtin_dfp_dtstsfi_gt_td</code> functions behave similarly, but
require that the type of the <code>value</code> argument be
<code>__Decimal64</code> and <code>__Decimal128</code> respectively.

 <p>The <code>__builtin_dfp_dtstsfi_eq</code> function returns a non-zero value
if and only if the number of signficant digits of its <code>value</code> argument
equals its <code>comparison</code> argument.  The
<code>__builtin_dfp_dtstsfi_eq_dd</code> and
<code>__builtin_dfp_dtstsfi_eq_td</code> functions behave similarly, but
require that the type of the <code>value</code> argument be
<code>__Decimal64</code> and <code>__Decimal128</code> respectively.

 <p>The <code>__builtin_dfp_dtstsfi_ov</code> function returns a non-zero value
if and only if its <code>value</code> argument has an undefined number of
significant digits, such as when <code>value</code> is an encoding of <code>NaN</code>. 
The <code>__builtin_dfp_dtstsfi_ov_dd</code> and
<code>__builtin_dfp_dtstsfi_ov_td</code> functions behave similarly, but
require that the type of the <code>value</code> argument be
<code>__Decimal64</code> and <code>__Decimal128</code> respectively.

 <p>The following built-in functions are also available for the PowerPC family
of processors, starting with ISA 3.0 or later
(<samp><span class="option">-mcpu=power9</span></samp>).  These string functions are described
separately in order to group the descriptions closer to the function
prototypes:
<pre class="smallexample">     int vec_all_nez (vector signed char, vector signed char);
     int vec_all_nez (vector unsigned char, vector unsigned char);
     int vec_all_nez (vector signed short, vector signed short);
     int vec_all_nez (vector unsigned short, vector unsigned short);
     int vec_all_nez (vector signed int, vector signed int);
     int vec_all_nez (vector unsigned int, vector unsigned int);
     
     int vec_any_eqz (vector signed char, vector signed char);
     int vec_any_eqz (vector unsigned char, vector unsigned char);
     int vec_any_eqz (vector signed short, vector signed short);
     int vec_any_eqz (vector unsigned short, vector unsigned short);
     int vec_any_eqz (vector signed int, vector signed int);
     int vec_any_eqz (vector unsigned int, vector unsigned int);
     
     vector bool char vec_cmpnez (vector signed char arg1, vector signed char arg2);
     vector bool char vec_cmpnez (vector unsigned char arg1, vector unsigned char arg2);
     vector bool short vec_cmpnez (vector signed short arg1, vector signed short arg2);
     vector bool short vec_cmpnez (vector unsigned short arg1, vector unsigned short arg2);
     vector bool int vec_cmpnez (vector signed int arg1, vector signed int arg2);
     vector bool int vec_cmpnez (vector unsigned int, vector unsigned int);
     
     vector signed char vec_cnttz (vector signed char);
     vector unsigned char vec_cnttz (vector unsigned char);
     vector signed short vec_cnttz (vector signed short);
     vector unsigned short vec_cnttz (vector unsigned short);
     vector signed int vec_cnttz (vector signed int);
     vector unsigned int vec_cnttz (vector unsigned int);
     vector signed long long vec_cnttz (vector signed long long);
     vector unsigned long long vec_cnttz (vector unsigned long long);
     
     signed int vec_cntlz_lsbb (vector signed char);
     signed int vec_cntlz_lsbb (vector unsigned char);
     
     signed int vec_cnttz_lsbb (vector signed char);
     signed int vec_cnttz_lsbb (vector unsigned char);
     
     unsigned int vec_first_match_index (vector signed char, vector signed char);
     unsigned int vec_first_match_index (vector unsigned char,
                                         vector unsigned char);
     unsigned int vec_first_match_index (vector signed int, vector signed int);
     unsigned int vec_first_match_index (vector unsigned int, vector unsigned int);
     unsigned int vec_first_match_index (vector signed short, vector signed short);
     unsigned int vec_first_match_index (vector unsigned short,
                                         vector unsigned short);
     unsigned int vec_first_match_or_eos_index (vector signed char,
                                                vector signed char);
     unsigned int vec_first_match_or_eos_index (vector unsigned char,
                                                vector unsigned char);
     unsigned int vec_first_match_or_eos_index (vector signed int,
                                                vector signed int);
     unsigned int vec_first_match_or_eos_index (vector unsigned int,
                                                vector unsigned int);
     unsigned int vec_first_match_or_eos_index (vector signed short,
                                                vector signed short);
     unsigned int vec_first_match_or_eos_index (vector unsigned short,
                                                vector unsigned short);
     unsigned int vec_first_mismatch_index (vector signed char,
                                            vector signed char);
     unsigned int vec_first_mismatch_index (vector unsigned char,
                                            vector unsigned char);
     unsigned int vec_first_mismatch_index (vector signed int,
                                            vector signed int);
     unsigned int vec_first_mismatch_index (vector unsigned int,
                                            vector unsigned int);
     unsigned int vec_first_mismatch_index (vector signed short,
                                            vector signed short);
     unsigned int vec_first_mismatch_index (vector unsigned short,
                                            vector unsigned short);
     unsigned int vec_first_mismatch_or_eos_index (vector signed char,
                                                   vector signed char);
     unsigned int vec_first_mismatch_or_eos_index (vector unsigned char,
                                                   vector unsigned char);
     unsigned int vec_first_mismatch_or_eos_index (vector signed int,
                                                   vector signed int);
     unsigned int vec_first_mismatch_or_eos_index (vector unsigned int,
                                                   vector unsigned int);
     unsigned int vec_first_mismatch_or_eos_index (vector signed short,
                                                   vector signed short);
     unsigned int vec_first_mismatch_or_eos_index (vector unsigned short,
                                                   vector unsigned short);
     
     vector unsigned short vec_pack_to_short_fp32 (vector float, vector float);
     
     vector signed char vec_xl_be (signed long long, signed char *);
     vector unsigned char vec_xl_be (signed long long, unsigned char *);
     vector signed int vec_xl_be (signed long long, signed int *);
     vector unsigned int vec_xl_be (signed long long, unsigned int *);
     vector signed __int128 vec_xl_be (signed long long, signed __int128 *);
     vector unsigned __int128 vec_xl_be (signed long long, unsigned __int128 *);
     vector signed long long vec_xl_be (signed long long, signed long long *);
     vector unsigned long long vec_xl_be (signed long long, unsigned long long *);
     vector signed short vec_xl_be (signed long long, signed short *);
     vector unsigned short vec_xl_be (signed long long, unsigned short *);
     vector double vec_xl_be (signed long long, double *);
     vector float vec_xl_be (signed long long, float *);
     
     vector signed char vec_xl_len (signed char *addr, size_t len);
     vector unsigned char vec_xl_len (unsigned char *addr, size_t len);
     vector signed int vec_xl_len (signed int *addr, size_t len);
     vector unsigned int vec_xl_len (unsigned int *addr, size_t len);
     vector signed __int128 vec_xl_len (signed __int128 *addr, size_t len);
     vector unsigned __int128 vec_xl_len (unsigned __int128 *addr, size_t len);
     vector signed long long vec_xl_len (signed long long *addr, size_t len);
     vector unsigned long long vec_xl_len (unsigned long long *addr, size_t len);
     vector signed short vec_xl_len (signed short *addr, size_t len);
     vector unsigned short vec_xl_len (unsigned short *addr, size_t len);
     vector double vec_xl_len (double *addr, size_t len);
     vector float vec_xl_len (float *addr, size_t len);
     
     vector unsigned char vec_xl_len_r (unsigned char *addr, size_t len);
     
     void vec_xst_len (vector signed char data, signed char *addr, size_t len);
     void vec_xst_len (vector unsigned char data, unsigned char *addr, size_t len);
     void vec_xst_len (vector signed int data, signed int *addr, size_t len);
     void vec_xst_len (vector unsigned int data, unsigned int *addr, size_t len);
     void vec_xst_len (vector unsigned __int128 data, unsigned __int128 *addr, size_t len);
     void vec_xst_len (vector signed long long data, signed long long *addr, size_t len);
     void vec_xst_len (vector unsigned long long data, unsigned long long *addr, size_t len);
     void vec_xst_len (vector signed short data, signed short *addr, size_t len);
     void vec_xst_len (vector unsigned short data, unsigned short *addr, size_t len);
     void vec_xst_len (vector signed __int128 data, signed __int128 *addr, size_t len);
     void vec_xst_len (vector double data, double *addr, size_t len);
     void vec_xst_len (vector float data, float *addr, size_t len);
     
     void vec_xst_len_r (vector unsigned char data, unsigned char *addr, size_t len);
     
     signed char vec_xlx (unsigned int index, vector signed char data);
     unsigned char vec_xlx (unsigned int index, vector unsigned char data);
     signed short vec_xlx (unsigned int index, vector signed short data);
     unsigned short vec_xlx (unsigned int index, vector unsigned short data);
     signed int vec_xlx (unsigned int index, vector signed int data);
     unsigned int vec_xlx (unsigned int index, vector unsigned int data);
     float vec_xlx (unsigned int index, vector float data);
     
     signed char vec_xrx (unsigned int index, vector signed char data);
     unsigned char vec_xrx (unsigned int index, vector unsigned char data);
     signed short vec_xrx (unsigned int index, vector signed short data);
     unsigned short vec_xrx (unsigned int index, vector unsigned short data);
     signed int vec_xrx (unsigned int index, vector signed int data);
     unsigned int vec_xrx (unsigned int index, vector unsigned int data);
     float vec_xrx (unsigned int index, vector float data);
</pre>
 <p>The <code>vec_all_nez</code>, <code>vec_any_eqz</code>, and <code>vec_cmpnez</code>
perform pairwise comparisons between the elements at the same
positions within their two vector arguments. 
The <code>vec_all_nez</code> function returns a
non-zero value if and only if all pairwise comparisons are not
equal and no element of either vector argument contains a zero. 
The <code>vec_any_eqz</code> function returns a
non-zero value if and only if at least one pairwise comparison is equal
or if at least one element of either vector argument contains a zero. 
The <code>vec_cmpnez</code> function returns a vector of the same type as
its two arguments, within which each element consists of all ones to
denote that either the corresponding elements of the incoming arguments are
not equal or that at least one of the corresponding elements contains
zero.  Otherwise, the element of the returned vector contains all zeros.

 <p>The <code>vec_cntlz_lsbb</code> function returns the count of the number of
consecutive leading byte elements (starting from position 0 within the
supplied vector argument) for which the least-significant bit
equals zero.  The <code>vec_cnttz_lsbb</code> function returns the count of
the number of consecutive trailing byte elements (starting from
position 15 and counting backwards within the supplied vector
argument) for which the least-significant bit equals zero.

 <p>The <code>vec_xl_len</code> and <code>vec_xst_len</code> functions require a
64-bit environment supporting ISA 3.0 or later.  The <code>vec_xl_len</code>
function loads a variable length vector from memory.  The
<code>vec_xst_len</code> function stores a variable length vector to memory. 
With both the <code>vec_xl_len</code> and <code>vec_xst_len</code> functions, the
<code>addr</code> argument represents the memory address to or from which
data will be transferred, and the
<code>len</code> argument represents the number of bytes to be
transferred, as computed by the C expression <code>min((len &amp; 0xff), 16)</code>. 
If this expression's value is not a multiple of the vector element's
size, the behavior of this function is undefined. 
In the case that the underlying computer is configured to run in
big-endian mode, the data transfer moves bytes 0 to <code>(len - 1)</code> of
the corresponding vector.  In little-endian mode, the data transfer
moves bytes <code>(16 - len)</code> to <code>15</code> of the corresponding
vector.  For the load function, any bytes of the result vector that
are not loaded from memory are set to zero. 
The value of the <code>addr</code> argument need not be aligned on a
multiple of the vector's element size.

 <p>The <code>vec_xlx</code> and <code>vec_xrx</code> functions extract the single
element selected by the <code>index</code> argument from the vector
represented by the <code>data</code> argument.  The <code>index</code> argument
always specifies a byte offset, regardless of the size of the vector
element.  With <code>vec_xlx</code>, <code>index</code> is the offset of the first
byte of the element to be extracted.  With <code>vec_xrx</code>, <code>index</code>
represents the last byte of the element to be extracted, measured
from the right end of the vector.  In other words, the last byte of
the element to be extracted is found at position <code>(15 - index)</code>. 
There is no requirement that <code>index</code> be a multiple of the vector
element size.  However, if the size of the vector element added to
<code>index</code> is greater than 15, the content of the returned value is
undefined.

 <p>The following built-in functions are available for the PowerPC family
of processors when hardware decimal floating point
(<samp><span class="option">-mhard-dfp</span></samp>) is available:
<pre class="smallexample">     long long __builtin_dxex (_Decimal64);
     long long __builtin_dxexq (_Decimal128);
     _Decimal64 __builtin_ddedpd (int, _Decimal64);
     _Decimal128 __builtin_ddedpdq (int, _Decimal128);
     _Decimal64 __builtin_denbcd (int, _Decimal64);
     _Decimal128 __builtin_denbcdq (int, _Decimal128);
     _Decimal64 __builtin_diex (long long, _Decimal64);
     _Decimal128 _builtin_diexq (long long, _Decimal128);
     _Decimal64 __builtin_dscli (_Decimal64, int);
     _Decimal128 __builtin_dscliq (_Decimal128, int);
     _Decimal64 __builtin_dscri (_Decimal64, int);
     _Decimal128 __builtin_dscriq (_Decimal128, int);
     unsigned long long __builtin_unpack_dec128 (_Decimal128, int);
     _Decimal128 __builtin_pack_dec128 (unsigned long long, unsigned long long);
</pre>
 <p>The following built-in functions are available for the PowerPC family
of processors when the Vector Scalar (vsx) instruction set is
available:
<pre class="smallexample">     unsigned long long __builtin_unpack_vector_int128 (vector __int128_t, int);
     vector __int128_t __builtin_pack_vector_int128 (unsigned long long,
                                                     unsigned long long);
</pre>
 </body></html>

